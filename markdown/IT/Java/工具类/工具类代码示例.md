Java-tools

# 1、regular-tools



```java
package com.example.common.utils;

/**
 * @description: 字符串正则验证工具类
 * @author: Administrator
 * @version: 1.0.0
 * @createTime: 2021/5/11 10:14
 */
public class StringRegexUtils {

    /**
     * 验证一个字符串是否是正整数
     * @param string
     */
    public static boolean isPositiveInteger(String string) {
        if (string.matches("^[1-9]+[0-9]*$")) {
            return true;
        }
        return false;
    }

		/**
     * 验证手机号码
     * <p>
     * 移动号码段:139、138、137、136、135、134、150、151、152、157、158、159、182、183、187、188、147
     * 联通号码段:130、131、132、136、185、186、145
     * 电信号码段:133、153、180、189
     */
    public static boolean checkPlainMobile(String plainMobile) {
        String regex = "^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\\d{8}$";
        return check(plainMobile, regex);
    }

    /**
     * 验证一个字符串是否是身份证号
     * @param string
     */
    public static boolean isIdCard(String string) {
        if (string.matches("^[1-9]\\d{5}(18|19|20)\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$)")) {
            return true;
        }
        return false;
    }
    
    
    
}

```



# 2、time-tools

```java
package com.example.common.utils;

import org.apache.commons.lang3.time.DateFormatUtils;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

/**
 * @description: 日期工具类
 * @author: Administrator
 * @version: 1.0.0
 * @createTime: 2021/1/20 20:26
 */
public class DateUtils {

    /**
     * 日期转字符串
     *
     * @param localDateTime 日期
     * @param pattern   格式
     */
    public static String localDateTime2String(LocalDateTime localDateTime, String pattern) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        String format = localDateTime.format(formatter);
        return format;
    }

    /**
     * 日期转字符串
     *
     * @param date 日期
     * @param pattern   格式
     */
    public static String date2String(Date date, String pattern) {
        Instant instant = date.toInstant();
        ZoneId zoneId = ZoneId.systemDefault();
        LocalDateTime localDateTime = instant.atZone(zoneId).toLocalDateTime();
        String s = localDateTime2String(localDateTime, pattern);
        return s;
    }

    /**
     * 字符串转日期
     *
     * @param dateString 日期字符串
     * @param pattern   格式
     */
    public static LocalDateTime string2LocalDateTime(String dateString, String pattern) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        LocalDateTime parse = LocalDateTime.parse(dateString, formatter);
        return parse;
    }

    /**
     * 字符串转日期
     *
     * @param dateString 日期字符串
     * @param pattern   格式
     */
    public static Date string2Date(String dateString, String pattern) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        LocalDateTime parse = LocalDateTime.parse(dateString, formatter);
        Date date = localDateTime2Date(parse);
        return date;
    }

    /**
     * 获取当前时间字符串
     * @param pattern   格式
     */
    public static String getCurrentString(String pattern) {
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        String format = formatter.format(now);
        return format;
    }

    /**
     * 获取当前时间
     * @param pattern   格式
     */
    public static LocalDateTime getCurrentLocalDateTime(String pattern) {
        LocalDateTime localDateTime = string2LocalDateTime(getCurrentString(pattern), pattern);
        return localDateTime;
    }


    /**
     * 获取当前时间毫秒值
     */
    public static long getLocalDateTimeMillis() {
        LocalDateTime now = LocalDateTime.now();
        ZonedDateTime zone = now.atZone(ZoneId.systemDefault());
        long milli = zone.toInstant().toEpochMilli();
        return milli;
    }


    /**
     * Date转LocalDateTime
     * @param date Date
     * @return LocalDateTime
     */
    public static LocalDateTime date2LocalDateTime(Date date) {
        try {
            Instant instant = date.toInstant();
            ZoneId zoneId = ZoneId.systemDefault();
            return instant.atZone(zoneId).toLocalDateTime();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }


    /**
     * LocalDateTime转Date
     * @param localDateTime LocalDateTime
     * @return Date
     */
    public static Date localDateTime2Date(LocalDateTime localDateTime) {
        Date date = null;
        try {
            ZoneId zoneId = ZoneId.systemDefault();
            ZonedDateTime zdt = localDateTime.atZone(zoneId);
            date = Date.from(zdt.toInstant());
        } catch (Exception e) {
            e.printStackTrace();
        }
        return date;
    }


    /**
     * 得到两个字符串时间差  格式yyyy-MM-dd HH:mm:ss
     *
     * @param start 2019-06-27 14:12:40
     * @param end   2019-08-27 14:12:40
     * @return 5270400000
     */
    public static long dateStringSubtraction(String start, String end) {
        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        try {
            Date date1 = df.parse(start);
            Date date2 = df.parse(end);
            return date2.getTime() - date1.getTime();
        } catch (ParseException e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 得到两个日期时间差
     *
     * @param start 开始时间
     * @param end 结束时间
     * @return 5270400000
     */
    public static long dateSubtraction(Date start, Date end) {
        return end.getTime() - start.getTime();
    }

    /**
     * 获取两个日期之间的天数
     * @param before    开始时间
     * @param after     结束时间
     * @return  
     */
    public static double getDistanceOfTwoDate(Date before, Date after) {
        long beforeTime = before.getTime();
        long afterTime = after.getTime();
        return (afterTime - beforeTime) / (1000 * 60 * 60 * 24);
    }

    /**
     * 获取系统当前时间戳
     *
     * @return 1566889186583
     */
    public static String getSystemTime() {
        String current = String.valueOf(System.currentTimeMillis());
        return current;
    }

    /**
     * 判断当前时间是否在[startTime, endTime]区间，注意时间格式要一致
     *
     * @param nowTime     当前时间
     * @param dateSection 时间区间   2018-01-08,2019-09-09
     * @return
     */
    public static boolean isEffectiveDate(Date nowTime, String dateSection) {
        try {
            String[] times = dateSection.split(",");
            String format = "yyyy-MM-dd";
            Date startTime = new SimpleDateFormat(format).parse(times[0]);
            Date endTime = new SimpleDateFormat(format).parse(times[1]);
            if (nowTime.getTime() == startTime.getTime()
                    || nowTime.getTime() == endTime.getTime()) {
                return true;
            }
            Calendar date = Calendar.getInstance();
            date.setTime(nowTime);

            Calendar begin = Calendar.getInstance();
            begin.setTime(startTime);

            Calendar end = Calendar.getInstance();
            end.setTime(endTime);

            if (isSameDay(date, begin) || isSameDay(date, end)) {
                return true;
            }
            if (date.after(begin) && date.before(end)) {
                return true;
            } else {
                return false;
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    public static boolean isSameDay(Calendar cal1, Calendar cal2) {
        if (cal1 != null && cal2 != null) {
            return cal1.get(0) == cal2.get(0) && cal1.get(1) == cal2.get(1) && cal1.get(6) == cal2.get(6);
        } else {
            throw new IllegalArgumentException("The date must not be null");
        }
    }

    public static long getTimeByDate(String time) {
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        try {
            Date date = format.parse(time);
            //日期转时间戳（毫秒）
            return date.getTime();
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 获取当前小时 ：2019-08-23 17
     *
     * @return 2019-08-27 17
     */
    public static String getCurrentHour() {
        GregorianCalendar calendar = new GregorianCalendar();
        int hour = calendar.get(Calendar.HOUR_OF_DAY);
        return String.valueOf(hour);
    }

    /**
     * 获取当前日期前一天
     *
     * @return 2019-08-26
     */
    public static String getBeforeDay() {

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        Date date = new Date();
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.add(Calendar.DAY_OF_MONTH, -1);
        date = calendar.getTime();
        return sdf.format(date);
    }

    /**
     * 获取最近七天
     *
     * @return 2019-08-20
     */
    public static String getServen() {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        Calendar c = Calendar.getInstance();
        c.add(Calendar.DATE, -7);
        Date monday = c.getTime();
        String preMonday = sdf.format(monday);
        return preMonday;
    }

    private static String[] parsePatterns = {"yyyy-MM-dd", "yyyy-MM-dd HH:mm:ss",
            "yyyy-MM-dd HH:mm", "yyyy-MM", "yyyy/MM/dd",
            "yyyy/MM/dd HH:mm:ss", "yyyy/MM/dd HH:mm", "yyyy/MM", "yyyy.MM.dd",
            "yyyy.MM.dd HH:mm:ss", "yyyy.MM.dd HH:mm", "yyyy.MM"};

    /**
     * 得到当前日期字符串 格式（yyyy-MM-dd）
     */
    public static String getDate() {
        return getDate("yyyy-MM-dd");
    }

    /**
     * 得到当前日期字符串 格式（yyyy-MM-dd） pattern可以为："yyyy-MM-dd" "HH:mm:ss" "E"
     */
    public static String getDate(String pattern) {
        return DateFormatUtils.format(new Date(), pattern);
    }

    public static int workDays(String strStartDate, String strEndDate) {
        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");

        Calendar cl1 = Calendar.getInstance();
        Calendar cl2 = Calendar.getInstance();

        try {
            cl1.setTime(df.parse(strStartDate));
            cl2.setTime(df.parse(strEndDate));

        } catch (ParseException e) {
            System.out.println("日期格式非法");
            e.printStackTrace();
        }

        int count = 0;
        while (cl1.compareTo(cl2) <= 0) {
            if (cl1.get(Calendar.DAY_OF_WEEK) != 7 && cl1.get(Calendar.DAY_OF_WEEK) != 1)
                count++;
            cl1.add(Calendar.DAY_OF_MONTH, 1);
        }
        return count;

    }


    /**
     * 获取当月的 天数
     */
    public static int getCurrentMonthDay() {
        Calendar a = Calendar.getInstance();
        a.set(Calendar.DATE, 1);
        a.roll(Calendar.DATE, -1);
        int maxDate = a.get(Calendar.DATE);
        return maxDate;
    }

    /**
     * 根据 年、月 获取对应的月份 的 天数
     */
    public static int getDaysByYearMonth(int year, int month) {
        Calendar a = Calendar.getInstance();
        a.set(Calendar.YEAR, year);
        a.set(Calendar.MONTH, month - 1);
        a.set(Calendar.DATE, 1);
        a.roll(Calendar.DATE, -1);
        int maxDate = a.get(Calendar.DATE);
        return maxDate;
    }

    /**
     * 根据日期 找到对应日期的 星期几
     *
     * @param date 比如传参：2018-07-13 将返回“周五”
     */
    public static String getDayOfWeekByDate(String date) {
        String dayOfweek = "-1";
        try {
            SimpleDateFormat myFormatter = new SimpleDateFormat("yyyy-MM-dd");
            Date myDate = myFormatter.parse(date);
            SimpleDateFormat formatter = new SimpleDateFormat("E");
            String str = formatter.format(myDate);
            dayOfweek = str;
        } catch (Exception e) {
            System.out.println("错误!");
        }
        return dayOfweek;
    }

    /**
     * 根据当前日期获得是星期几
     * time=yyyy-MM-dd
     * @return
     */
    public static String getWeek(String time) {
        String Week = "";
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
        Calendar c = Calendar.getInstance();
        try {
            c.setTime(format.parse(time));
        } catch (ParseException e) {
            e.printStackTrace();
        }

        int wek = c.get(Calendar.DAY_OF_WEEK);

        if (wek == 1) {
            Week += "星期日";
        }
        if (wek == 2) {
            Week += "星期一";
        }
        if (wek == 3) {
            Week += "星期二";
        }
        if (wek == 4) {
            Week += "星期三";
        }
        if (wek == 5) {
            Week += "星期四";
        }
        if (wek == 6) {
            Week += "星期五";
        }
        if (wek == 7) {
            Week += "星期六";
        }
        return Week;
    }

    /**
     * 根据日期和工作日天数计算开始工作日日期
     * @param dateStr   日期字符串
     * @param days  工作日天数
     * @return
     */
    public static String getBeginWorkDate(String dateStr, int days) {
        // 格式化日期为yyyy-MM-dd
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
        Date date = null;
        try {
            date = format.parse(dateStr);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        // 设置日历
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        int wek = calendar.get(Calendar.DAY_OF_WEEK);
        // 计算开始时间yyyy-MM-dd HH:mm:ss
        long beginMilliSecond;
        if (wek == 1) {
            // 周日
            beginMilliSecond = date.getTime() - (days - 1 + (2 * ((days / 7) + 1))) * 1000 * 60 * 60 * 24;
        } else if (wek == 2) {
            // 周一
            beginMilliSecond = date.getTime() - (days - 1 + (2 * ((days / 7) + 1))) * 1000 * 60 * 60 * 24;
        } else if (wek == 3) {
            // 周二
            beginMilliSecond = date.getTime() - (days - 1 + (2 * ((days / 7) + 1))) * 1000 * 60 * 60 * 24;
        } else if (wek == 4) {
            // 周三
            beginMilliSecond = date.getTime() - (days - 1 + (2 * (days / 7))) * 1000 * 60 * 60 * 24;
        } else if (wek == 5) {
            // 周四
            beginMilliSecond = date.getTime() - (days - 1 + (2 * (days / 7))) * 1000 * 60 * 60 * 24;
        } else if (wek == 6) {
            // 周五
            beginMilliSecond = date.getTime() - (days - 1 + (2 * (days / 7))) * 1000 * 60 * 60 * 24;
        } else {
            // wek == 7，周六
            beginMilliSecond = date.getTime() - (days + (2 * (days / 7))) * 1000 * 60 * 60 * 24;
        }
        Date beginDate = new Date(beginMilliSecond);
        String beginDateStr = date2String(beginDate, "yyyy-MM-dd HH:mm:ss");
        return beginDateStr;
    }

    /**
     * 根据日期和工作日天数计算开始工作日日期
     * @param dateStr   日期字符串
     * @return
     */
    public static int getWeekWorkDayCount(String dateStr) {
        // 格式化日期为yyyy-MM-dd
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
        Date date = null;
        try {
            date = format.parse(dateStr);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        int wek = getWeekDayOfWeek(date);
        // 计算开始时间yyyy-MM-dd HH:mm:ss
        int workDay = 0;
        if (wek == 1 || wek == 7) {
            // 周日、周六直接5天拉满
            workDay = 5;
        } else {
            workDay = wek - 1;
        }
        return workDay;
    }

    /**
     * 根据日期获取当天日历是星期几（西方习惯，1-周日，7-周六）
     * @param date
     * @return
     */
    public static int getWeekDayOfWeek(Date date) {
        // 设置日历
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        int wek = calendar.get(Calendar.DAY_OF_WEEK);
        return wek;
    }

    /**
     * 根据日期获取当天日历是星期几（西方习惯，1-周日，7-周六）
     * @param dateString
     * @return
     */
    public static int getWeekDayOfWeek(String dateString) {
        Date date = string2Date(dateString, "yyyy-MM-dd");
        // 设置日历
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        int wek = calendar.get(Calendar.DAY_OF_WEEK);
        return wek;
    }

    /**
     * 计算两个日期之间的工作日天数[beforeDate,afterDate](暂不考虑法定节假日)
     * @param beforeDate
     * @param afterDate
     * @return
     */
    public static int getWorkDayCountBetween2Date(Date beforeDate, Date afterDate) {
        long beforeDateTime = beforeDate.getTime();
        long afterDateTime = afterDate.getTime();
        long tempDateTime;
        Date tempDate;
        if (beforeDateTime > afterDateTime) {
            // 调换日期
            tempDate = beforeDate;
            beforeDate = afterDate;
            afterDate = tempDate;
            // 调换毫秒值
            tempDateTime = beforeDateTime;
            beforeDateTime = afterDateTime;
            afterDateTime = tempDateTime;
        }
        // 分别计算开始日期与截止日期的日历星期数
        int beforeWek = getWeekDayOfWeek(beforeDate);
        int afterWek = getWeekDayOfWeek(afterDate);
        // 计算开始日期与截止日期之间的自然日天数
        int days = (int) ((afterDateTime - beforeDateTime) / (1000 * 60 * 60 * 24)) + 1;
        // 用bakDays进行计算
        int bakDays = days;
        // 开始排除开始日期那一排的非工作日
        if (beforeWek == 1) {
            // 周日，需要减去一天
            days -= 1;
        } else {
            // 非周日，需要减去两天
            days -= (2 * (bakDays / 7 > 0 ? 1 : 0));
        }
        // 开始排除非开始日期和截止日期那一排的非工作日
        int differRows = (bakDays / 7 - 1);
        if (differRows > 0) {
            days -= (2 * differRows);
        }
        // 排除截止日期那一排的非工作日天数
        if (afterWek == 1) {
            days -= (2 * (bakDays / 7 > 0 ? 1 : 1));
        } else if (afterWek == 7) {
            days -= 1;
        }
        return days;
    }

    /**
     * 计算两个日期之间的工作日天数[beforeDate,afterDate](暂不考虑法定节假日)
     * @param beforeDateString
     * @param afterDateString
     * @return
     */
    public static int getWorkDayCountBetween2Date(String beforeDateString, String afterDateString) {
        Date beforeDate = string2Date(beforeDateString, "yyyy-MM-dd");
        Date afterDate = string2Date(afterDateString, "yyyy-MM-dd");
        int workDays = getWorkDayCountBetween2Date(beforeDate, afterDate);
        return workDays;
    }

    /**
     * 计算两个日期之间的自然日天数[beforeDate,afterDate]
     * @param beforeDate
     * @param afterDate
     * @return
     */
    public static int getDayCountBetween2Date(Date beforeDate, Date afterDate) {
        long beforeDateTime = beforeDate.getTime();
        long afterDateTime = afterDate.getTime();
        int days = (int) ((afterDateTime - beforeDateTime) / (1000 * 60 * 60 * 24)) + 1;
        return Math.abs(days);
    }

    /**
     * 获取指定日期所在那周的实时工作日天数
     * @param dateString
     * @return
     */
    public static int getWeekDayCount(String dateString) {
        Date date = string2Date(dateString, "yyyy-MM-dd");
        int wek = getWeekDayOfWeek(date);
        int workDay = 0;
        if (wek == 1 || wek == 7) {
            workDay = 5;
        } else {
            workDay = wek - 1;
        }
        return workDay;
    }

    /**
     * 获取指定日期所在那月的实时工作日天数
     * @return
     */
    public static int getMonthWorkDayCount(String dateString) {
        int wek = getWeekDayOfWeek(dateString);
        Date date = string2Date(dateString, "yyyy-MM-dd");
        // 设置日历
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        int days = calendar.get(Calendar.DAY_OF_MONTH);
        int workDays = 0;
        if (wek == 1) {
            workDays = days - (2 * (days / 7) + 2);
        } else if (wek == 7) {
            workDays = days - (2 * (days / 7) + 1);
        } else {
            workDays = days - 2 * (days / 7);
        }
        return workDays;
    }

    /**
     * 获取当月第一天日期
     * @return
     */
    public static Date getFirstDateOfCurrentMonth() {
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.MONTH, 0);
        calendar.set(Calendar.DAY_OF_MONTH, 1);
        return calendar.getTime();
    }

    /**
     * 获取当月第一天日期
     * @return
     */
    public static String getFirstDateStrOfCurrentMonth() {
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.MONTH, 0);
        calendar.set(Calendar.DAY_OF_MONTH, 1);
        String dateString = date2String(calendar.getTime(), "yyyy-MM-dd");
        return dateString;
    }

    /**
     * 获取本月最后一天
     * @return String
     * **/
    public static String getMonthEnd() {
        Calendar cal = Calendar.getInstance();
        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));
        Date time = cal.getTime();
        return new SimpleDateFormat("yyyy-MM-dd").format(time) + " 23:59:59";
    }

    /**
     * 获取本周的最后一天
     * @return String
     * **/
    public static String getWeekEnd() {
        Calendar cal = Calendar.getInstance();
        cal.set(Calendar.DAY_OF_WEEK, cal.getActualMaximum(Calendar.DAY_OF_WEEK));
        cal.add(Calendar.DAY_OF_WEEK, 1);
        Date time = cal.getTime();
        return new SimpleDateFormat("yyyy-MM-dd").format(time) + " 23:59:59";
    }

    /**
     * 获取本年的第一天
     * @return String
     * **/
    public static String getYearStart() {
        return new SimpleDateFormat("yyyy").format(new Date()) + "-01-01";
    }

    /**
     * 获取本年的最后一天
     * @return String
     * **/
    public static String getYearEnd() {
        Calendar calendar = Calendar.getInstance();
        calendar.set(Calendar.MONTH, calendar.getActualMaximum(Calendar.MONTH));
        calendar.set(Calendar.DAY_OF_MONTH, calendar.getActualMaximum(Calendar.DAY_OF_MONTH));
        Date currYearLast = calendar.getTime();
        return new SimpleDateFormat("yyyy-MM-dd").format(currYearLast) + " 23:59:59";
    }

    /**
     * 获取当前周的周一的日期
     * @param date 传入当前日期
     * @return
     */
    public static Date getThisWeekMonday(Date date) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        // 获得当前日期是一个星期的第几天
        int dayWeek = cal.get(Calendar.DAY_OF_WEEK);
        if (1 == dayWeek) {
            cal.add(Calendar.DAY_OF_MONTH, -1);
        }
        // 设置一个星期的第一天，按中国的习惯一个星期的第一天是星期一
        cal.setFirstDayOfWeek(Calendar.MONDAY);
        // 获得当前日期是一个星期的第几天
        int day = cal.get(Calendar.DAY_OF_WEEK);
        cal.add(Calendar.DATE, cal.getFirstDayOfWeek() - day);
        return cal.getTime();
    }

    /**
     * 获取当前周的周一的日期字符串
     * @param dateStr 传入当前日期
     * @return
     */
    public static String getThisWeekMonday(String dateStr) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(string2Date(dateStr, "yyyy-MM-dd"));
        // 获得当前日期是一个星期的第几天
        int dayWeek = cal.get(Calendar.DAY_OF_WEEK);
        if (1 == dayWeek) {
            cal.add(Calendar.DAY_OF_MONTH, -1);
        }
        // 设置一个星期的第一天，按中国的习惯一个星期的第一天是星期一
        cal.setFirstDayOfWeek(Calendar.MONDAY);
        // 获得当前日期是一个星期的第几天
        int day = cal.get(Calendar.DAY_OF_WEEK);
        cal.add(Calendar.DATE, cal.getFirstDayOfWeek() - day);
        return date2String(cal.getTime(), "yyyy-MM-dd");
    }

    public static void main(String[] args) {
/*        String yyyyMMddHHmmssSSS = getCurrentString("yyyyMMddHHmmssSSS");
        System.out.println(yyyyMMddHHmmssSSS);


        System.out.println(LocalDateTime.now().getHour());
        System.out.println(LocalDateTime.now().plusDays(1));
        System.out.println(LocalDate.now().getYear());*/

        int daysByYearMonth = getDaysByYearMonth(2021, 6);
        System.out.println(daysByYearMonth);
    }
}
```



# 3、http/https request tool class

## 3.1、OkHttpUtils

```java
package com.example.common.utils;

import com.alibaba.fastjson.JSON;
import okhttp3.*;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.IOException;
import java.net.URLEncoder;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class OkHttpUtils {
    private static volatile OkHttpClient okHttpClient = null;
    private static volatile Semaphore semaphore = null;
    private Map<String, String> headerMap;
    private Map<String, String> paramMap;
    private String url;
    private Request.Builder request;

    /**
     * 初始化okHttpClient，并且允许https访问
     */
    private OkHttpUtils() {
        if (okHttpClient == null) {
            synchronized (OkHttpUtils.class) {
                if (okHttpClient == null) {
                    TrustManager[] trustManagers = buildTrustManagers();
                    okHttpClient = new OkHttpClient.Builder()
                            .connectTimeout(15, TimeUnit.SECONDS)
                            .writeTimeout(20, TimeUnit.SECONDS)
                            .readTimeout(20, TimeUnit.SECONDS)
                            .sslSocketFactory(createSSLSocketFactory(trustManagers), (X509TrustManager) trustManagers[0])
                            .hostnameVerifier((hostName, session) -> true)
                            .retryOnConnectionFailure(true)
                            .build();
                    addHeader("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36");
                }
            }
        }
    }

    /**
     * 用于异步请求时，控制访问线程数，返回结果
     *
     * @return
     */
    private static Semaphore getSemaphoreInstance() {
        //只能1个线程同时访问
        synchronized (OkHttpUtils.class) {
            if (semaphore == null) {
                semaphore = new Semaphore(0);
            }
        }
        return semaphore;
    }

    /**
     * 创建OkHttpUtils
     *
     * @return
     */
    public static OkHttpUtils builder() {
        return new OkHttpUtils();
    }

    /**
     * 添加url
     *
     * @param url
     * @return
     */
    public OkHttpUtils url(String url) {
        this.url = url;
        return this;
    }

    /**
     * 添加参数
     *
     * @param key   参数名
     * @param value 参数值
     * @return
     */
    public OkHttpUtils addParam(String key, String value) {
        if (paramMap == null) {
            paramMap = new LinkedHashMap<>(16);
        }
        paramMap.put(key, value);
        return this;
    }

    /**
     * 添加请求头
     *
     * @param key   参数名
     * @param value 参数值
     * @return
     */
    public OkHttpUtils addHeader(String key, String value) {
        if (headerMap == null) {
            headerMap = new LinkedHashMap<>(16);
        }
        headerMap.put(key, value);
        return this;
    }

    /**
     * 初始化get方法
     *
     * @return
     */
    public OkHttpUtils get() {
        request = new Request.Builder().get();
        StringBuilder urlBuilder = new StringBuilder(url);
        if (paramMap != null) {
            urlBuilder.append("?");
            try {
                for (Map.Entry<String, String> entry : paramMap.entrySet()) {
                    urlBuilder.append(URLEncoder.encode(entry.getKey(), "utf-8")).
                            append("=").
                            append(URLEncoder.encode(entry.getValue(), "utf-8")).
                            append("&");
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            urlBuilder.deleteCharAt(urlBuilder.length() - 1);
        }
        request.url(urlBuilder.toString());
        return this;
    }

    /**
     * 初始化post方法
     *
     * @param isJsonPost true等于json的方式提交数据，类似postman里post方法的raw
     *                   false等于普通的表单提交
     * @return
     */
    public OkHttpUtils post(boolean isJsonPost) {
        RequestBody requestBody;
        if (isJsonPost) {
            String json = "";
            if (paramMap != null) {
                json = JSON.toJSONString(paramMap);
            }
            requestBody = RequestBody.create(MediaType.parse("application/json; charset=utf-8"), json);
        } else {
            FormBody.Builder formBody = new FormBody.Builder();
            if (paramMap != null) {
                paramMap.forEach(formBody::add);
            }
            requestBody = formBody.build();
        }
        request = new Request.Builder().post(requestBody).url(url);
        return this;
    }

    /**
     * 同步请求
     *
     * @return
     */
    public String sync() {
        setHeader(request);
        try {
            Response response = okHttpClient.newCall(request.build()).execute();
            assert response.body() != null;
            return response.body().string();
        } catch (IOException e) {
            e.printStackTrace();
            return "请求失败：" + e.getMessage();
        }
    }

    /**
     * 异步请求，有返回值
     */
    public String async() {
        StringBuilder buffer = new StringBuilder("");
        setHeader(request);
        okHttpClient.newCall(request.build()).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                buffer.append("请求出错：").append(e.getMessage());
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                assert response.body() != null;
                buffer.append(response.body().string());
                getSemaphoreInstance().release();
            }
        });
        try {
            getSemaphoreInstance().acquire();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return buffer.toString();
    }

    /**
     * 异步请求，带有接口回调
     *
     * @param callBack
     */
    public void async(ICallBack callBack) {
        setHeader(request);
        okHttpClient.newCall(request.build()).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callBack.onFailure(call, e.getMessage());
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                assert response.body() != null;
                callBack.onSuccessful(call, response.body().string());
            }
        });
    }

    /**
     * 为request添加请求头
     *
     * @param request
     */
    private void setHeader(Request.Builder request) {
        if (headerMap != null) {
            try {
                for (Map.Entry<String, String> entry : headerMap.entrySet()) {
                    request.addHeader(entry.getKey(), entry.getValue());
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }


    /**
     * 生成安全套接字工厂，用于https请求的证书跳过
     *
     * @return
     */
    private static SSLSocketFactory createSSLSocketFactory(TrustManager[] trustAllCerts) {
        SSLSocketFactory ssfFactory = null;
        try {
            SSLContext sc = SSLContext.getInstance("SSL");
            sc.init(null, trustAllCerts, new SecureRandom());
            ssfFactory = sc.getSocketFactory();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return ssfFactory;
    }

    private static TrustManager[] buildTrustManagers() {
        return new TrustManager[]{
                new X509TrustManager() {
                    @Override
                    public void checkClientTrusted(X509Certificate[] chain, String authType) {
                    }

                    @Override
                    public void checkServerTrusted(X509Certificate[] chain, String authType) {
                    }

                    @Override
                    public X509Certificate[] getAcceptedIssuers() {
                        return new X509Certificate[]{};
                    }
                }
        };
    }

    /**
     * 自定义一个接口回调
     */
    public interface ICallBack {

        void onSuccessful(Call call, String data);

        void onFailure(Call call, String errorMsg);

    }

    /**
     * 使用教程
     */
    public static void main(String[] args) {
        // get请求，方法顺序按照这种方式，切记选择post/get一定要放在倒数第二，同步或者异步倒数第一，才会正确执行
        OkHttpUtils.builder().url("请求地址，http/https都可以")
                // 有参数的话添加参数，可多个
                .addParam("参数名", "参数值")
                .addParam("参数名", "参数值")
                // 也可以添加多个
                .addHeader("Content-Type", "application/json; charset=utf-8")
                .get()
                // 可选择是同步请求还是异步请求
                //.async();
                .sync();

        // post请求，分为两种，一种是普通表单提交，一种是json提交
        OkHttpUtils.builder().url("请求地址，http/https都可以")
                // 有参数的话添加参数，可多个
                .addParam("参数名", "参数值")
                .addParam("参数名", "参数值")
                // 也可以添加多个
                .addHeader("Content-Type", "application/json; charset=utf-8")
                // 如果是true的话，会类似于postman中post提交方式的raw，用json的方式提交，不是表单
                // 如果是false的话传统的表单提交
                .post(true)
                .sync();

        // 选择异步有两个方法，一个是带回调接口，一个是直接返回结果
        OkHttpUtils.builder().url("")
                .post(false)
                .async();

        OkHttpUtils.builder().url("").post(false).async(new OkHttpUtils.ICallBack() {
            @Override
            public void onSuccessful(Call call, String data) {
                // 请求成功后的处理
            }

            @Override
            public void onFailure(Call call, String errorMsg) {
                // 请求失败后的处理
            }
        });
    }
}
```

### Use MultipartBody to upload multiple types of data at the same time

Upload multiple files and key-value pairs at the same time

```
示例一：

OkHttpClient client = new OkHttpClient();
MultipartBody multipartBody = new MultipartBody.Builder()
    .setType(MultipartBody.FORM)
    .addFormDataPart("name", "zhangsan")
    .addFormDataPart("age", "20")
    .addFormDataPart("file", file.getName(),
		RequestBody.create(MediaType.parse("application/octet-stream"), file))
	.build();

Request request = new Request.Builder()
    .url(url)
    .post(multipartBody)
    .build();
client.newCall(request).enqueue(new Callback() {
@Override
public void onFailure(Call call, IOException e) {
}
@Override
public void onResponse(Call call, Response response) throws IOException {
}
});


示例二:
	/**
     * 上传多张图片及参数
     * @param reqUrl URL地址
     * @param params 参数
     * @param pic_key 上传图片的关键字
     * @param paths  图片路径
     */
    public Observable<String> sendMultipart(String reqUrl,Map<String, String> params,String pic_key, List<File> files){
        return Observable.create(new Observable.OnSubscribe<String>(){

            @Override
            public void call(Subscriber<? super String> subscriber) {
                MultipartBody.Builder multipartBodyBuilder = new MultipartBody.Builder();
                multipartBodyBuilder.setType(MultipartBody.FORM);
                //遍历map中所有参数到builder
                if (params != null){
                    for (String key : params.keySet()) {
                        multipartBodyBuilder.addFormDataPart(key, params.get(key));
                    }
                }
                //遍历paths中所有图片绝对路径到builder，并约定key如“upload”作为后台接受多张图片的key
                if (files != null){
                    for (File file : files) {
                        multipartBodyBuilder.addFormDataPart(pic_key, file.getName(), RequestBody.create(MEDIA_TYPE_PNG, file));
                    }
                }
                //构建请求体
                RequestBody requestBody = multipartBodyBuilder.build();

                Request.Builder RequestBuilder = new Request.Builder();
                RequestBuilder.url(reqUrl);// 添加URL地址
                RequestBuilder.post(requestBody);
                Request request = RequestBuilder.build();
                mOkHttpClient.newCall(request).enqueue(new Callback() {
                    @Override
                    public void onFailure(Call call, IOException e) {
                        subscriber.onError(e);
                        subscriber.onCompleted();
                        call.cancel();
                    }

                    @Override
                    public void onResponse(Call call, Response response) throws IOException {
                        String str = response.body().string();
                        subscriber.onNext(str);
                        subscriber.onCompleted();
                        call.cancel();
                    }
                });
            }
        });
    }
```



# 4、file stream tools



```java
package com.example.common.utils;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.poi.util.IOUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.net.URLEncoder;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.UUID;

/**
 * @description: 文件工具类
 * @author: Administrator
 * @version: 1.0.0
 * @createTime: 2021/1/25 16:03
 */
@Slf4j
public class FileUtils {

    private enum ContentTypeEnums {
        IMAGE_JPEG("image/jpeg"),
        IMAGE_JPG("image/jpg"),
        IMAGE_PNG("image/png"),
        IMAGE_GIF("image/gif"),
        OFFICE_DOC("application/msword"),
        OFFICE_DOCX("application/vnd.openxmlformats-officedocument.wordprocessingml.document"),
        OFFICE_PPT("application/vnd.ms-powerpoint"),
        OFFICE_PPTX("application/vnd.openxmlformats-officedocument.presentationml.presentation"),
        OFFICE_EXCEL_XLS("application/vnd.ms-excel"),
        OFFICE_EXCEL_XLSX("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"),
        VIDEO_MPEG("video/mpeg"),
        RMVB("application/vnd.rn-realmedia-secure"),
        TEXT_XML("text/xml"),
        PDF("application/pdf"),
        ZIP("application/zip"),
        GZIP("application/gzip"),
        STREAM("application/octet-stream"),
        ;

        private String type;

        ContentTypeEnums(String type) {
            this.type = type;
        }
    }

    /**
     * 支持文件类型，jpeg,jpg,png,gif,doc,docx,pdf
     */
    private static final String UPLOAD_FILE_TYPE = "image/jpeg,image/jpg,image/png,image/gif,application/msword," +
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/pdf";

    /**
     * 支持最大上传文件大小：10M
     */
    private static final long MAXIMUM_UPLOAD_FILE_SIZE = 10 * 1024 * 1024;

    @Value("${bashFilePath}")
    private String bashFilePath;

    /**
     * 功能描述: 上传文件
     *
     * @param file  待上传的文件
     * @param operator  操作人
     */
    public void uploadFile(MultipartFile file, String operator) {
        // 1_校验文件
        if (file.isEmpty()) {
            throw new RuntimeException("文件不能为空！");
        }
        if (file.getSize() > MAXIMUM_UPLOAD_FILE_SIZE) {
            throw new RuntimeException("文件超过10M，暂不支持");
        }
        if (!UPLOAD_FILE_TYPE.contains(file.getContentType())) {
            log.info("文件格式暂不支持");
        }
        // 2_开始上传
        String fileType = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf("."));
        String newFileName = UUID.randomUUID().toString() + fileType;
        String nowString = DateUtils.getCurrentString("yyyyMMdd");
        File destFile = new File(bashFilePath + nowString + fileType);
        try (FileInputStream fis = (FileInputStream) file.getInputStream(); FileOutputStream fos = new FileOutputStream(destFile)) {
            if (!destFile.getParentFile().exists()) {
                destFile.getParentFile().mkdirs();
            }
            FileChannel inChannel = fis.getChannel();
            FileChannel outChannel = fos.getChannel();
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            while (true) {
                buffer.clear();
                int r = inChannel.read(buffer);
                if (r == -1) {
                    break;
                }
                buffer.flip();
                outChannel.write(buffer);
            }
        } catch (Exception e) {
            log.error("文件上传失败,文件名:{},失败原因:{}", file.getOriginalFilename(), e);
        }
    }

    /**
     * 功能描述: 下载文件
     *
     * @param response  响应
     * @param filePath  源文件文件路径
     */
    public void download(HttpServletResponse response, String filePath) {
        File file = new File(filePath);
        try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));
             OutputStream outputStream = response.getOutputStream()
        ) {
            byte[] buf = new byte[1024];
            int len = 0;
            response.reset();
            response.setContentType("application/octet-stream");
            response.addHeader("Content-Length", "" + file.length());
            response.addHeader("Content-Disposition", "attachment;fileName=" + URLEncoder.encode(file.getName(), "UTF-8"));
            while ((len = bis.read(buf)) > 0) {
                outputStream.write(buf, 0, len);
                outputStream.flush();
            }
        } catch (Exception e) {
            log.error("文件下载失败,文件名:{},失败原因:{}", file.getName(), e);
        }
    }
    
    /**
     * 功能描述: 下载远程url文件
     * 这里主要使用URL获取文件流：
     *  URL url = new URL(audioUrl);
     *  InputStream inputStream = url.openStream();
     * @param response  响应
     * @param url  源文件url文件路径
     */
    public void downloadUrlFile(HttpServletResponse response, String url) {
        String fileName = new File(url).getName();
        try (BufferedInputStream bis = new BufferedInputStream(new URL(url).openStream());
             OutputStream outputStream = response.getOutputStream()
        ) {
            byte[] buf = new byte[1024];
            int len = 0;
            response.reset();
            response.setContentType("application/octet-stream");
            // response.addHeader("Content-Length", "" + file.length());
            response.addHeader("Content-Disposition", "attachment;fileName=" + URLEncoder.encode(fileName, "UTF-8"));
            while ((len = bis.read(buf)) > 0) {
                outputStream.write(buf, 0, len);
                outputStream.flush();
            }
        } catch (Exception e) {
            log.error("文件下载失败,文件名:{},失败原因:{}", fileName, e);
        }
    }

    /**
     * 复制文件
     * @param sourceFilePath 源文件路径
     * @param destFilePath  目的地路径
     */
    public void copyFile(String sourceFilePath, String destFilePath) {
        File sourceFile = new File(sourceFilePath);
        File destFile = new File(destFilePath);
        try (FileInputStream fis = new FileInputStream(sourceFile); FileOutputStream fos = new FileOutputStream(destFile)) {
            if (!destFile.getParentFile().exists()) {
                destFile.getParentFile().mkdirs();
            }
            FileChannel inChannel = fis.getChannel();
            FileChannel outChannel = fos.getChannel();
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            while (true) {
                buffer.clear();
                int r = inChannel.read(buffer);
                if (r == -1) {
                    break;
                }
                buffer.flip();
                outChannel.write(buffer);
            }
        } catch (Exception e) {
            log.error("文件复制失败,文件名:{},失败原因:{}", sourceFile.getName(), e);
        }
    }

    /**
     * 获取文件MD5散列值
     * @param filePath 文件路径
     */
    private static String getFileMd5String(String filePath) {
        String md5Hex = null;
        try (FileInputStream fis = new FileInputStream(filePath);) {
            md5Hex = DigestUtils.md5Hex(IOUtils.toByteArray(fis));
            IOUtils.closeQuietly(fis);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return md5Hex;
    }

    /**
     * 两个文件是否相同
     * @param filePath1 文件路径1
     * @param filePath2 文件路径2
     */
    public static boolean isSameFile(String filePath1, String filePath2) {
        if (StringUtils.isBlank(filePath1) || StringUtils.isBlank(filePath2)) {
            return false;
        }
        File file1 = new File(filePath1);
        File file2 = new File(filePath2);
        if (!file1.getName().substring(file1.getName().lastIndexOf(".")).equals(file2.getName().substring(file2.getName().lastIndexOf(".")))
                || file1.length() != file2.length()
        ) {
            return false;
        }
        String md5String1 = getFileMd5String(filePath1);
        String md5String2 = getFileMd5String(filePath2);
        return md5String1.equals(md5String2);
    }
}

```





# 5、paging tools

## 5.1、MySQL-version

```java
package com.example.common.dto;

/**
 * @description: MySQL版分页对象
 * @author: Administrator
 * @version: 1.0.0
 * @createTime: 2021/6/11 13:18
 *
 * mybatis查询时xml中sql写法：
 * 在末尾 + limit #{offset}, #{pageSize}
 */
public class PageMySQL {

    private int pageSize = 15;
    private int pageNo = 1;
    private int offset = 0;

    public int getPageSize() {
        return pageSize;
    }

    public void setPageSize(int pageSize) {
        this.pageSize = pageSize;
    }

    public int getPageNo() {
        return pageNo;
    }

    public void setPageNo(int pageNo) {
        this.pageNo = pageNo;
    }

    public int getOffset() {
        offset = (pageNo - 1) * pageSize;
        return offset;
    }

    public void setOffset(int offset) {
        this.offset = offset;
    }
}

```



## 5.2、Oracle-version

```java
package com.example.common.dto;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @description: Oracle版分页对象
 * @author: Administrator
 * @version: 1.0.0
 * @createTime: 2021/6/11 13:22
 *
 * 对应mybatis中SQL尾部加
 * and rownumber &gt;= #{rowNumStart,jdbcType=NUMERIC}
 * and rownumber &lt;= #{rowNumEnd,jdbcType=NUMERIC}
 */
public class PageOracle<T> {

    private int pageSize = 15;
    private int pageNo = 1;
    private int rowNumStart;
    private int rowNumEnd;
    private int totalPages;
    private int totalRecords;
    private List<T> results;
    private Map<String, Object> params = new HashMap<>();//搜索条件

    public int getRowNumStart() {
        rowNumStart = (pageNo - 1) * pageNo + 1;
        return rowNumStart;
    }

    public void setRowNumStart(int rowNumStart) {
        this.rowNumStart = rowNumStart;
    }

    public int getRowNumEnd() {
        rowNumEnd = (pageNo - 1) * pageNo + pageSize;
        return rowNumEnd;
    }

    public void setRowNumEnd(int rowNumEnd) {
        this.rowNumEnd = rowNumEnd;
    }

    public int getTotalPages() {
        totalPages = totalRecords / pageSize + 1;
        return totalPages;
    }

    public void setTotalPages(int totalPages) {
        this.totalPages = totalPages;
    }

    public int getTotalRecords() {
        return totalRecords;
    }

    public void setTotalRecords(int totalRecords) {
        this.totalRecords = totalRecords;
    }
}

```

