# 零、基础概念

##  为什么要使用数据库

```
数据保存在内存
    优点：存取速度快
    缺点：数据不能永久保存

数据保存在文件
    优点：数据永久保存
    缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便
    
数据保存在数据库
    1）数据永久保存
    2）使用SQL语句，查询方便效率高。
    3）管理数据方便    
```

## 什么是SQL

```
结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。
作用：用于存取数据、查询、更新和管理关系数据库系统。
```

## 什么是MySQL

```
MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。
MySQL是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (RelationalDatabase Management System，关系数据库管理系统) 应用软件之一。
在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。
```

## 数据库三大范式是什么

```
第一范式：每个列都不可以再拆分。
第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。
第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。
在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。
```

### 数据库范式

#### **参考答案**：

```
1 第一范式（1NF）

在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。
所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。

2 第二范式（2NF）

第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。
第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。

3 第三范式（3NF）

满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。（我的理解是消除冗余）
```



## MySQL有关权限的表都有哪几个

```
MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。
下面分别介绍一下这些表的结构和内容：
user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
db权限表：记录各个帐号在各个数据库上的操作权限。
table_priv权限表：记录数据表级的操作权限。
columns_priv权限表：记录数据列级的操作权限。
host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。
```

## MySQL的binlog有有几种录入格式？分别有什么区别

```
有三种格式，statement，row和mixed。
statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。

row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。

mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。

此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。
```



# 一、存储引擎

## MySQL存储引擎类型

### 1、你知道哪些 **MySQL** 存储引擎

```
InnoDB		。这是最常用的事务型存储引擎;
MyISAM		。这是最常用的非事务型存储引擎，也是 MySQL5.6 之前的默认引擎;
MEMORY		。这是一种易失性非事务型存储引擎;
ARCHIVE		。这是一种只允许查询和新增数据而不允许修改的非事务型存储引擎;
CSV				。这是以 CSV 格式存储的非事务型存储引擎;
MERGE			。将多个类似的 MyISAM 表分组为一个表，可以处理非事务性表，默认情况下包括这些表。
EXAMPLE		。可以使用此引擎创建表，但不能存储或获取数据。
BLACKHOLE	。接受要存储的数据，但始终返回空。
FEDERATED	。将数据存储在远程数据库中。

```

### 2、常见的存储引擎都适用于哪些场景

| 功能         | InnoDB | MyISAM | MEMORY | ARCHIVE |
| ------------ | ------ | ------ | ------ | ------- |
| 存储限制     | 64TB   | 256TB  | RAM    | NONE    |
| 是否支持事务 | Yes    | No     | No     | No      |
| 支持全文索引 | No     | Yes    | No     | No      |
| 支持数索引   | Yes    | Yes    | Yes    | No      |
| 支持哈希索引 | No     | No     | Yes    | No      |
| 支持数据缓存 | Yes    | No     | N/A    | No      |
| 支持外键     | Yes    | No     | No     | No      |

## InnoDB 和 MyISAM对比

### 1、InnoDB 和 MyISAM 的区别有哪些

```
InnoDB 支持事务，而 MyISAM 不支持事务;
InnoDB 支持行级锁，而 MyISAM 支持表级锁; InnoDB 支持 MVCC, 而 MyISAM 不支持;
InnoDB 支持外键，而 MyISAM 不支持;
InnoDB 不支持全文索引，而 MyISAM 支持。
```

### 2、InnoDB 和 MyISAM，select count(\*)哪个更快，为什么?

```
MyISAM 更快。因为 MyISAM 内部维护了一个计数器，可以直接调取。
```

### 3、MyISAM Static 和 MyISAM Dynamic 有什么区别

```
在 MyISAM Static 上的所有字段有固定宽度;
动态 MyISAM 表将具有像 TEXT，BLOB 等字段，以适应不同长度的数据类型;
MyISAM Static 在受损情况下更容易恢复。
```



# 二、数据类型

## 字符串

### 1、char 和 varchar 的区别是什么

```
char 是限制字符串长度固定，长度值范围是 1 到 255，如果申请了 char(10)的空间，那么无论实际存储多少内容，该字段都占用 10 个字符（不够的参数用空格填充）。检索 CHAR 值时需删除尾随空格。
varchar 是可变长的字符串，也就是说申请的只是最大长度，占用的空间为实际字符长度+1;

在检索效率上来讲，char > varchar。因此在使用中，如果确定某个字段的值的长度，可以使用 char，否则应该尽量使用 varchar。
例如 存储用户 MD5 加密后的密码，则应该使用char。
```

### 2、varchar(10)和 int(10)分别有什么含义?

```
varchar 的 10 代表了申请的空间长度，也是可以存储的数据的最大长度;

int 的10只是代表了展示的长度，不足10位以0填充。也就是说，int(1)和 int(10)所能存储的数字大小以及占用的空间都是相同的，只是在展示时按照长度展示而已。
```

### 3、如果要存储用户的密码散列，应该使用什么字段进行存储

```
密码散列、用户身份证号等固定长度的字符串，应该使用 char 而不是 varchar 来存储，这样可以节省空间且提高检索效率。
```

### 4、列的字符串类型有哪些

```
SET
BLOB
ENUM
CHAR
TEXT
VARCHAR
```

### 5、BLOB 和 TEXT 有什么区别

```
BLOB 是一个二进制对象，可以容纳可变数量的数据。有四种类型的 BLOB
 TINYBLOB
 BLOB
 MEDIUMBLOB 和
 LONGBLOB
它们只能在所能容纳价值的最大长度上有所不同。

TEXT
TEXT 是一个不区分大小写的 BLOB。四种 TEXT 类型
 TINYTEXT
 TEXT
 MEDIUMTEXT 和  LONGTEXT
它们对应于四种 BLOB 类型，并具有相同的最大长度和存储要求。

BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对 TEXT 值不区分大小写。
```

### 6、什么是非标准字符串类型？

```
以下是非标准字符串类型：

TINYTEXT

TEXT

MEDIUMTEXT

LONGTEXT
```



## 时间

### 1、如何在 Unix 和 MySQL 时间戳之间进行转换

```
 从 Unix 时间戳转换为 MySQL 时间戳可以使用 FROM_UNIXTIME 命令
 从 MySQL 时间戳转换为 Unix 时间戳可以使用 UNIX_TIMESTAMP 命令
```

### 2、MySQL 中，如果一个表有一列定义为 TIMESTAMP，则 会发生什么?

```
每当行被更改时，时间戳字段将获取当前时间戳。
```

### 3、TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？

```
创建表时 TIMESTAMP 列用 Zero 更新。

只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP 修饰符就将时间戳字段更新为当前时间
```



## 数字

### 1、怎样才能找出最后一次插入时分配了哪个自动增量

```
LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值，并且不需 要指定表名称。
```

### 2、列设置为 AUTO INCREMENT 时，如果在表中达到最大 值，会发生什么情况

```
它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。
```

## Enum

### 1、在 MySQL 中 ENUM 的用法是什么？

```
ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。

SQL 语法如下：

Create table size(name ENUM('Small,'Medium','Large');
```



# 三、索引

## 概念

### 1、什么是索引? 

```
索引是一种数据结构，可以帮助我们快速地进行数据的查找
```

### 2、**使用索引查询一定能提高查询的性能吗？为什么**

通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。

索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:

基于一个范围的检索，一般查询返回结果集小于表中记录数的30%

基于非唯一性索引的检索

## 优缺点

### 1、索引有什么优缺点? 

```
索引的优点有:
 可以保证数据库表中每一行的数据的唯一性
 可以大大加快数据的索引速度
 加速表与表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
 通过使用索引，可以在时间查询的过程中，使用优化隐藏器，提高系统的性能

索引的缺点有:
 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
 索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大
 以表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度
```



## 索引数据结构

### 1、索引的数据结构与什么有关

```
索引的数据结构和具体存储引擎的实现有关;在 MySQL 中使用较多的索引有 Hash 索引，B+树索引等。
我们经常使用的 InnoDB 存储引擎的默认索引实现为:B+树索引。
```

### 2、Hash 索引和 B+树索引有什么区别

```
首先要知道 Hash 索引和 B+树索引的底层实现原理:
hash 索引底层就是 hash 表，进行查找时，调用一次 hash 函数就可以 获取到相应的键值，之后进行回表查询获得实际数据。
B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出 发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要 回表查询数据。

可以看出他们有以下的不同:
一般情况下，hash 索引进行等值查询更快，但是却无法进行范围查询。 因为在 hash 索引中经过 hash 函数建立索引之后，索引的顺序与原顺序 无法保持一致，不能支持范围查询。而 B+树的的所有节点皆遵循(左节 点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。
hash 索引不支持使用索引进行排序，原因同上;
hash 索引不支持模糊查询以及多列索引的最左前缀匹配。原因也是因为hash 函数的不可预测。AAAA 和 AAAAB 的索引没有相关性。
hash 索引任何时候都避免不了回表查询数据，而 B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测。当某个 键值存在大量重复的时候，发生 hash 碰撞，此时效率可能极差。而 B+ 树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且 树的高度较低。

因此，在大多数情况下，直接选择 B+树索引可以获得稳定且较好的查询速度，而不需要使用 hash 索引。
```

### 3、B树和B+树的区别

```
1、在B树中，你可以将键和值存放在内部节点和叶子节点；
但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。
2、B+树的叶子节点有一条单向链表相连，而B树的叶子节点各自独立
```

### 4、使用B树的好处

B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。

### 5、使用B+树的好处

由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间

### 6、Hash索引和B+树所有有什么区别或者说优劣呢?

```
首先要知道Hash索引和B+树索引的底层实现原理：
hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。
B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。

那么可以看出他们有以下的不同：
hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。

而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。

hash索引不支持使用索引进行排序，原理同上。
hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。
hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。

因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。
```

### 7、数据库为什么使用B+树而不是B树

```
B树只适合随机检索，而B+树同时支持随机检索和顺序检索；

B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；

B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。

B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。
```

### 8、B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据

```
在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。
当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。
```

### 9、 非聚簇索引一定会回表查询吗？

```
不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。
举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee
where age < 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。
```

### 10、联合索引是什么？为什么需要注意联合索引中的顺序？

```
MySQL可以使用多个字段同时建立一个索引，叫做联合索引。

在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因为:

MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。

当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。

因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。
```



## 分类

### 1、MySQL中的索引类型有哪些

```
 普通索引。是最基本的索引，它没有任何限制;
 唯一索引。索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一;
 主键索引。是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值;
 组合索引。指多个字段上创建的索引，只有在查询条件中使用了创建 索引时的第一个字段，索引才会被使用，使用组合索引时遵循最左前 缀集合;
 全文索引:主要用来查找文本中的关键字，而不是直接与索引中的值 相比较，mysql 中 MyISAM 支持全文索引而 InnoDB 不支持。
```

### 2、非聚簇索引一定会回表查询吗

```mysql
不一定。这涉及到查询语句所要求的字段是否全部命中了索引，如果全部 命中了索引，那么就不必再进行回表查询。
举个简单的例子，假设我们在员工表的年龄上建立了索引,那么当进行 
select age
from employee
where age < 20
的查询时，在索引的叶子节点上，已经包含了 age 信息，不会再次进行回表查询。
```

### 3、什么是联合索引**?**为什么需要注意联合索引中的顺序

```
MySQL 可以使用多个字段同时建立一个索引，叫做联合索引。
在联合索引 中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。
具体原因为:
MySQL 使用索引时需要索引有序，假设现在建立了"name,age,school"的 联合索引，那么索引的排序为:
先按照 name 排序，如果 name 相同，则 按照 age 排序，如果 age 的值也相等，则按照 school 进行排序。
当进行查询时，此时索引仅仅按照 name 严格有序，因此必须首先使用 name 字段进行等值查询，之后对于匹配到的列而言，其按照 age 字段严
格有序，此时可以使用 age 字段用做索引查找......
因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性 高的列放在前面。
此外可以根据特例的查询或者表结构进行单独的调整。
```

### 4、MyISAM索引与InnoDB索引的区别

```
InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。
InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。
```



## 维护

### 1、在建立索引的时候，需要考虑哪些因素? 

```
建立索引的时候一般要考虑到字段的使用频率，经常作为条件进行查询的字段比较适合; 
如果需要建立联合索引的话，还需要考虑联合索引中的顺序;
此外也要考虑其他方面，比如防止过多的所有对表造成太大的压力，这些都和实际的表结构以及查询方式有关。
```

### 2、怎样知道语句运行很慢的原因

```
MySQL 提供了 explain 命令来查看语句的执行计划。
MySQL 在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到 对语句的分析，也就是执行计划，其中包含了许多信息。
可以通过其中和 索引有关的信息来分析是否命中了索引，例如 possilbe_key、key、key_len等字段，分别说明了此语句可能会使用的索引，实际使用的索引以及使用 的索引长度。
```

### 3、索引失效原因

```
 使用不等于查询;
 列参与了数学运算或者函数;
 在字符串 like 时左边是通配符，类似于'%aaa';
 当 MySQL 分析全表扫描比使用索引快的时候不使用索引;
 当使用联合索引，前面一个条件为范围查询，后面的即使符合最左前缀原则，也无法使用索引。
```



# 四、锁

## 概念

### 1、对 MySQL 锁是怎么理解的?

```
当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些 机制来保证访问的次序，锁机制就是这样的一个机制。

就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情 况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来， 其他人只有等他使用完毕才可以再次使用。
```

### 2、加锁有什么好处

```
数据库是一个多用户使用的共享资源。
当多个用户并发地存取数据时，在 数据库中就会产生多个事务同时存取同一数据的情况。
若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。
加锁是实现数据库并发控制的一个非常重要的技术。
当事务在对某个数据 对象进行操作前，先向系统发出请求，对其加锁。
加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。
```

### 3、隔离级别与锁的关系

```
在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突 在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁;

在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须 等待事务执行完毕以后才释放共享锁。

SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完 成。
```



## 分类

### 1、MySQL中有哪几种锁

```
MyISAM 支持表锁，InnoDB 支持表锁和行锁，默认为行锁。
表级锁：开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高，并发度最低;
行级锁：开销大，加锁慢;会出现死锁;锁定粒度最小，发生锁冲突的 概率最低，并发度也最高;
页面锁：开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度 界于表锁和行锁之间，并发度一般。
```

### 2、什么是死锁?锁等待?通过数据库哪些表可以监控

```
死锁是指两个或多个事务在同一资源上互相占用，并请求加锁时，而导致的恶性循环现象。
当多个事务以不同顺序试图加锁同一资源时，就会产生死锁。

锁等待:mysql 数据库中，不同 session 在更新同行数据中，会出现锁等待。

重要的三张锁的监控表 innodb_trx，innodb_locks，innodb_lock_waits
```

### 3、MySQL 中 InnoDB 引擎的行锁是如何实现的

```
 InnoDB 是基于索引来完成行锁
 例如，select * from tab_with_index where id = 1 for update;for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列， 如果 id 不是索引键那么 InnoDB 将完成表锁。
```

### 4、哪些优化锁的方法

```
 读写分离;
 分段加锁;
 减少锁持有的时间;
 多个线程尽量以相同的顺序去获取资源;
 尽可能让所有的数据检索都通过索引来完成;
 合理设计索引;
 尽可能减少基于范围的数据检索过滤条件;
 不要将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。
```

### 5、从锁的类别上分MySQL都有哪些锁呢?

```
从锁的类别上来讲，有共享锁和排他锁。
共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。
排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其 他的排他锁，共享锁都相斥。

用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。

锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。 他们的加锁开销从大到小，并发能力也是从大到小。
```

### 6、InnoDB存储引擎的锁的算法有三种

```
Record lock:单个行记录上的锁
Gap lock:间隙锁，锁定一个范围，不包括记录本身 
Next-key lock:record+gap 锁定一个范围，包含记录本身

相关知识点:
1. innodb对于行的查询使用next-key lock
2. Next-locking keying为了解决Phantom Problem幻读问题
3. 当查询的索引含有唯一属性时，将next-key lock降级为record key
4. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
5. 有两种方式显式关闭gap锁:(除了外键约束和唯一性检查外，其余情况仅使用record lock)
A.将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1
```

### 7、什么是死锁?怎么解决?

```
死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。
常见的解决死锁的方法
1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率;
3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率;
如果业务处理不好可以用分布式事务锁或者使用乐观锁
```

### 8、数据库的乐观锁和悲观锁是什么?怎么实现的?

```
数据库管理系统(DBMS)中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。
乐观并发控制(乐观锁)和悲观并发控制(悲观锁)是并 发控制主要采用的技术手段。
悲观锁:假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。
实现方式:使用数据库中的锁机制
乐观锁:假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。
实现方式:乐一般会使用版本号机制或CAS算法实现。

两种锁的使用场景
从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下(多读场景)，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。

但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。
```



# 五、事务

## 概念

### 1、什么是事务

```
事务是一系列的操作，他们要符合 ACID 特性。
最常见的理解就是:事务中的操作要么全部成功，要么全部失败。
```

### 2、ACID 是什么

```
ACID，是数据库事务正确执行的四个基本要素的缩写。
包含:原子性 (Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性 (Durability)。

 A=Atomicity，指的是原子性。即要么全部成功，要么全部失败，不可能只执行一部分操作。
 C=Consistency，指的是一致性。即系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态，不会存在中间状态。
 I=Isolation，指的是隔离性。通常来说，一个事务在完全提交之前，对其他事务是不可见的。
 D=Durability，指的是持久性。一旦事务提交，那么就永远是这样子了，哪怕系统崩溃也不会影响结果。
```

### 3、同时有多个事务在进行会怎么样

```
多事务的并发进行一般会造成以下几个问题:
 更新丢失(Lost Update):当两个或多个事务选择同一行，然后基 于最初选定的值更新该行时，由于每个事务都不知道其他事务的存 在，就会发生丢失更新问题，最后的更新覆盖了由其他事务所做的更 新;
 脏读(Dirty Reads):一个事务正在对一条记录做修改，在这个事 务没有提交前， 这条记录的数据就一直处于不确定状态;这时，另 一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这 些脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系， 这种现象被形象地叫做脏读;
 发现其读出的数据已经发生了改变、或某些记录已经被删除了!这种 现象就叫做“不可重复读”;
 幻读(Phantom Reads):一个事务按相同的查询条件重新读取以 前检索过的数据，却发现其他事务插入了满足其查询条件的新数据， 这种现象就称为“幻读” 。
```

### 4、MySQL 的事务隔离级别有哪些

```
 未提交读(READ UNCOMMITTED)。这个隔离级别下，其他事务可以看到本事务没有提交的部分修改，因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚);
 已提交读(READ COMMITTED)。其他事务只能读取到本事务已经提交的部分，这个隔离级别有不可重复读的问题，在同一个事务内的两次读取，拿到的结果竟然不一样，因为另外一个事务对数据进行了修改;
 REPEATABLE READ(可重复读)。可重复读隔离级别解决了上面不可重复读的问题，但是仍然有一个新问题，就是幻读。当你读取 id> 10 的数据行时，对涉及到的所有行加上了读锁，此时例外一个事务新插入了一条 id=11 的数据，因为是新插入的，所以不会触发上面的锁 的排斥，那么进行本事务进行下一次的查询时会发现有一条 id=11 的数据，而上次的查询操作并没有获取到，再进行插入就会有主键冲突的问题;
 SERIALIZABLE(可串行化)。这是最高的隔离级别，可以解决上面提到的所有问题，因为他强制将所以的操作串行执行，这会导致并发性能极速下降，因此也不是很常用。
```

### 5、InnoDB 使用的是哪种隔离级别

```
InnoDB 默认使用的是可重复读隔离级别。
```

### 6、REPEATABLE READ 隔离级别下 MVCC 如何工作

```
 SELECT:InnoDB 会根据以下条件检查每一行记录:
	第一，InnoDB 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的; 
	第二，行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除。
 INSERT:InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。
 DELETE:InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。
 UPDATE:InnoDB 为插入的一行新记录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识保存这两个版本号，使大多数操作都不用加锁。它不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。
```

### 7、InnoDB 如何开启手动提交事务?

```
InnoDB 默认是自动提交事务的，每一次 SQL 操作(非 select 操作)都会自动提交一个事务。
如果要手动开启事务需要设置 set autocommit=0 禁止自动提交事务，相当于开启手动提交事务。
```

### 8、在 InnoDB 中设置了 autocommit=0，添加一条信息之 后没有手动执行提交操作，请问这条信息可以被查到吗

```
autocommit=0 表示禁止自动事务提交，在添加操作之后没有进行手动提 交，默认情况下其他连接客户端是查询不到此条新增数据的。
```



## log

### 1、MySQL 的 binlog 有几种录入格式，它们之间有什么区别

```
有三种格式:statement、row 和 mixed。
 statement 模式下，记录单元为语句。即每一个 sql 造成的影响会记 录。由于 sql 的执行是有上下文的，因此在保存的时候需要保存相关 的信息，同时还有一些使用了函数之类的语句无法被记录复制。
 row 级别下，记录单元为每一行的改动，基本是可以全部记下来但是 由于很多操作，会导致大量行的改动(比如 alter table)，因此这种 模式的文件保存的信息太多，日志量太大。
 mixed， 一种折中的方案，普通操作使用 statement 记录，当无法 使用 statement 的时候使用 row。

```

### 2、事务是如何通过日志来实现的

```
在 Innodb 存储引擎中，事务日志是通过 redo 和 innodb 的存储引擎日志缓冲(Innodb log buffer)来实现的。
当开始一个事务的时候，会记录该事务的 lsn(log sequence number)号;
当事务执行时，会往 InnoDB 存储引擎的日志缓存里面插入事务日志;
当事务提交时，必须将存储引擎的日志缓冲写入磁盘(通过 innodb_flush_log_at_trx_commit 来控制)，也就是写数据前，需要先写日志。这种方式称为“预写日志方式”，innodb 通过此方式来保证事务的完整性。
也就意味着磁盘上存储的数据页和内存缓冲池上面的页是不同步的，是先写入 redo log，然后写入 data file，因此是一种异步的方式。
```



# 六、表结构设计

## 主键

### 1、为什么要尽量设定一个主键?

```
主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有 主键，也建议添加一个自增长的 ID 列作为主键。设定了主键之后，在后续 的删改查的时候会更加快速以及确保操作数据范围安全。
```

### 2、主键使用自增 ID 还是 UUID

```
推荐使用自增 ID，不要使用 UUID。
因为在 InnoDB 存储引擎中，主键索引是作为聚簇索引存在的。也就是说，主键索引的 B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)。 如果主键索引是自增 ID，那么只需要不断向后排列即可;如果是 UUID，由于到来的 ID 与原来的大小不确定，会造成非常多的数据插入，数据移动， 然后导致产生很多的内存碎片，进而造成插入性能的下降。
总之，在数据量大一些的情况下,用自增 ID 性能会更好。
```

### 3、主键和候选键有什么区别

```
表格的每一行都由主键唯一标识, 一个表只有一个主键。

主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。
```

### 4、一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？

```
(1)如果表的类型是 MyISAM，那么是 18

因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里，重启 MySQL 自增主键的最大ID 也不会丢失

（2）如果表的类型是 InnoDB，那么是 15。

InnoDB 表只是把自增主键的最大 ID 记录到内存中，所以重启数据库或者是对表进行OPTIMIZE 操作，都会导致最大 ID 丢失
```

### 5、主键 超键 候选键 外键是什么

#### 定义

**超键(super key)**: 在关系中能唯一标识元组的属性集称为关系模式的超键

**候选键(candidate key)**: 不含有多余属性的超键称为候选键。也就是在候选键中，若再删除属性，就不是键了！

**主键(primary key)**: 用户选作元组标识的一个候选键程序主键

**外键(foreign key)**：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。

#### 举例

比如有如下数据：

|   学号   |  姓名  | 性别 | 年龄 |  系别  |   专业   |
| :------: | :----: | :--: | :--: | :----: | :------: |
| 20020612 |  李辉  |  男  |  20  | 计算机 | 软件开发 |
| 20060613 |  张明  |  男  |  18  | 计算机 | 软件开发 |
| 20060614 | 王小玉 |  女  |  19  |  物理  |   力学   |
| 20060615 | 李淑华 |  女  |  17  |  生物  |  动物学  |
| 20060616 |  赵静  |  男  |  21  |  化学  | 食品化学 |
| 20060617 |  赵静  |  女  |  20  |  生物  |  植物学  |

1. 超键

   在关系中能唯一标识元组的属性集称为关系模式的超键。

   于是我们从例子中可以发现 学号是标识学生实体的唯一标识。那么该元组的超键就为学号。

   除此之外我们还可以把它跟其他属性组合起来，比如：

   (`学号`，`性别`)

   (`学号`，`年龄`)

   这样也是超键.

2. 候选键

   不含多余属性的超键为候选键。

   根据例子可知，学号是一个可以唯一标识元组的唯一标识，因此学号是一个候选键，实际上，候选键是超键的子集，比如 （学号，年龄）是超键，但是它不是候选键。因为它还有了额外的属性。

3. 主键

   用户选择的候选键作为该元组的唯一标识，那么它就为主键。

   简单的说，例子中的元组的候选键为学号，但是我们选定他作为该元组的唯一标识，那么学号就为主键。

4. 外键

   外键是相对于主键的，比如在学生记录里，主键为学号，在成绩单表中也有学号字段，因此学号为成绩单表的外键，为学生表的主键。

#### 总结

**主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的。**



## 字段为什么要求定义为 not null

```
MySQL 官网这样介绍:
NULL columns require additional space in the rowto record whether their values are NULL. For MyISAM tables, each NULL columntakes one bit extra, rounded up to the nearest byte.
也就是:null 值会占用更多的字节，且会在程序中造成很多与预期不符的情况。
```

## truncate delete drop 的区别

#### 解答一：

|          | delete                                   | drop                                                   | truncate                       |
| -------- | ---------------------------------------- | ------------------------------------------------------ | ------------------------------ |
| 类型     | 属于DML                                  | 属于DDL                                                | 属于DDL                        |
| 回滚     | 可回滚                                   | 不可回滚                                               | 不可回滚                       |
| 删除内容 | 表结构还在，删除表的全部或者一部分数据行 | 从数据库中删除表，所有的数据行，索引和权限也会被删除。 | 表结构还在，删除表中的所有数据 |
| 删除速度 | 删除速度慢，需要逐行删 除                | 删除速度最快                                           | 删除速度快                     |

因此，在不再需要一张表的时候，用drop;在想删除部分数据行时候，用delete;在保留表而删除所有 数据的时候用truncate。

#### 解答二：

```
drop(DDL 语句)：是不可逆操作，会将表所占用空间全部释放掉；
truncate(DDL 语句)：只针对于删除表的操作，在删除过程中不会激活与表有关的删除触发器并且不会把删除记录放在日志中；当表被 truncate 后，这个表和索引会恢复到初始大小；
delete(DML 语句)：可以删除表也可以删除行，但是删除记录会被计入日志保存，而且表空间大小不会恢复到原来；
执行速度：drop>truncate>delete。
```

#### 解答三：

```
drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始 delete删除表中数据，可以加where字句。

（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。

（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。

（3） 一般而言，drop > truncate > delete

（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view

（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。

（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。

（7） delete语句为DML（Data Manipulation Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。

（8） truncate、drop是DDL（Data Define Language),操作立即生效，原数据不放到 rollback segment中，不能回滚

（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老是想触发trigger,还是用delete。

（10） Truncate table 表名 速度快,而且效率高,因为: truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。

（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。

（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。
```



##  百万级别或以上的数据如何删除

关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。

所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。

1. 所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）

2. 然后删除其中无用数据（此过程需要不到两分钟）

   alter table user_index drop KEY name; 

   alter table user_index drop KEY id_card; 

   alter table user_index drop KEY information; 

   alter table user_index 

   -- 重新定义字段 

   MODIFY id int, 

   drop PRIMARY KEY

3. 删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。

4. 与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。

# 七、优化

## SQL优化

### 1、explain 出来的各种 item 的意义是什么

```
 select_type 。表示查询中每个 select 子句的类型;
 type。表示 MySQL 在表中找到所需行的方式，又称“访问类型”;
 possible_keys 。指出 MySQL 能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用;
 key。显示 MySQL 在查询中实际使用的索引，若没有使用索引，显 示为 NULL;
 key_len。表示索引中使用的字节数，可通过该列计算查询中使用的 索引的长度;
 ref。表示上述表的连接匹配条件，即哪些列或常量被用于查找索引 列上的值 ;
 Extra。包含不适合在其他列中显示但十分重要的额外信息。
```

### 2、profile 的意义以及使用场景有哪些

```
Profile 用来分析 sql 性能的消耗分布情况。当用 explain 无法解决慢 SQL 的时候，需要用 profile 来对 sql 进行更细致的分析，找出 sql 所 花的时间大部分消耗在哪个部分，确认 sql 的性能瓶颈。
```

### 3、说一说你能想到的 sql 语句优化，至少五种

```
 避免 select *，将需要查找的字段列出来;
 使用连接(join)来代替子查询;
 拆分大的 delete 或 insert 语句;
 使用 limit 对查询结果的记录进行限定;
 用 exists 代替 in 是一个好的选择;
 用 Where 子句替换 HAVING 子句，因为 HAVING 只会在检索出所 有记录之后才对结果集进行过滤;
 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达 式运算，否则系统将可能无法正确使用索引尽量避免在 where 子句 中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全 表扫描;
 尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放 弃使用索引而进行全表扫描;
 尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使 用索引而进行全表扫描。
```

### 4、MySQL 数据库服务器性能分析的方法命令有哪些?

```
Show status 一些值得监控的变量值： 

Bytes*received 和 Bytes*sent 和服务器之间来往的流量。 

Com 服务器正在执行的命令。 

Created 在查询执行期限间创建的临时表和文件。 

Handler 存储引擎操作。 

Select 不同类型的联接执行计划。

Sort_* 几种排序信息。 
Show session status like ‘Select’; 
Show profiles SET profiling=1; 
Show profiles\G Show profile;
```

### 5、MySQL 数据优化

```
 优化数据类型
o 避免使用 NULL，NULL 需要特殊处理, 大多数时候应该使用 NOT NULL，或者使用一个特殊的值，如 0，-1 作为默认值。
o 仅可能使用更小的字段，MySQL 从磁盘读取数据后是存储到内存中的，然后使用 cpu 周期和磁盘 I/O 读取它，这意味着越小的数据类型占用的空间越小. 

 小心字符集转换
o 客户端或应用程序使用的字符集可能和表本身的字符集不一样，这需要MySQL 在运行过程中隐含地进行转换，此外，要确定字符集如 UTF-8 是否支持多字节字符，因此它们需要更多的存储空间。

 优化 count(mycol) 和 count()*

 优化子查询
o 遇到子查询时，MySQL 查询优化引擎并不是总是最有效的，这就是为什么经常将子查询转换为连接查询的原因了，优化器已经能够正确处理连接查询了，当然要注意的一点是，确保连接表 (第二个表) 的连接列是有索引的，在第一个表上 MySQL 通常会相对于第二个表的查询子集进行一次全表扫描，这是嵌套循环算法的一部分。

 优化 UNION
o 在跨多个不同的数据库时使用 UNION 是一个有趣的优化方法，UNION 从两个互不关联的表中返回数据，这就意味着不会出现重复的行，同时也必须对数据进行排序，我们知道排序是非常耗费资源的，特别是对大表的排序。
o UNION ALL 可以大大加快速度，如果你已经知道你的数据不会包括重复行，或者你不在乎是否会出现重复的行，在这两种情况下使用UNION ALL 更适合。此外，还可以在应用程序逻辑中采用某些方法避免出现重复的行，这样 UNION ALL 和 UNION 返回的结果都是一样的，但 UNION ALL 不会进行排序。
```

### 6、优化查询过程中的数据访问

```
访问数据太多导致查询性能下降

确定应用程序是否在检索大量超过需要的数据，可能是太多行或列

确认MySQL服务器是否在分析大量不必要的数据行

避免犯如下SQL语句错误

查询不需要的数据。解决办法:使用limit解决

多表关联返回全部列。解决办法:指定列名

总是返回全部列。解决办法:避免使用SELECT * 

重复查询相同的数据。解决办法:可以缓存数据，下次直接读取缓存 

是否在扫描额外的记录。解决办法: 使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化: 

使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。

改变数据库和表的结构，修改数据表范式

重写SQL语句，让优化器可以以更优的方式执行查询。
```

### 7、优化长难的查询语句

```
一个复杂查询还是多个简单查询 
	MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多 
	使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。 
	切分查询，将一个大的查询分为多个小的相同的查询 


 一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。 
 分解关联查询，让缓存的效率更高。
 执行单个查询可以减少锁的竞争。
 在应用层做关联更容易对数据库进行拆分。
 查询效率会有大幅提升。
 较少冗余记录的查询。
```

### 8、优化特定类型的查询语句

```
count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名) 

MyISAM中，没有任何where条件的count(*)非常快。

当有where条件时，MyISAM的count统计不一定比其它引擎快。 

可以使用explain查询近似值，用近似值替代count(*)

增加汇总表 

使用缓存
```

### 9、优化关联查询 

```
确定ON或者USING子句中是否有索引。

确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。
```

### 10、优化子查询

```
用关联查询替代
优化GROUP BY和DISTINCT
这两种查询据可以使用索引来优化，是最有效的优化方法 
关联查询中，使用标识列分组的效率更高
如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。 
WITH ROLLUP超级聚合，可以挪到应用程序处理
```

### 11、优化LIMIT分页

```
LIMIT偏移量大的时候，查询效率较低

可以记录上次查询的最大ID，下次查询时直接根据该ID来查询
```

### 12、优化UNION查询

UNION ALL的效率高于UNION

### 13、优化WHERE子句

```mysql
1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表 扫描，如:
	select id from t where num is null
	-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询: 
	select id from t where num=0;

3.应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描。 

4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫 描，如:
	select id from t where num=10 or num=20
	-- 可以这样查询:
	select id from t where num=10 union all select id from t where num=20;
	
5.in 和 not in 也要慎用，否则会导致全表扫描，如:
	select id from t where num in(1,2,3)
	-- 对于连续的数值，能用 between 就不要用 in 了: 
	select id from t where num between 1 and 3;

6.下面的查询也将导致全表扫描:select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。

7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时;它必须在编译时进行选择。然而，如果在 编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描:
	select id from t where num=@num
	-- 可以改为强制查询使用索引:
	select id from t with(index(索引名)) where num=@num;
	
8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫 描。如:
	select id from t where num/2=100;
	-- 应改为:
	select id from t where num=100*2;
	
9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。 如:
	select id from t where substring(name,1,3)=’abc’;
  -- name以abc开头的id应改为:
	select id from t where name like ‘abc%’;
	
10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法 正确使用索引。
```



## 慢查询

### 1、统计过慢查询吗?对慢查询都怎么优化过?

```
业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。
慢查询的优化首先要搞明白慢的原因是什么。
是查询条件没有命中索引?
是 load 了不需要的数据列?
还是数据量太大? 
所以优化也是针对这三个方向来的:
1. 首先分析语句，看看是否 load 了额外的数据，可能是查询了多余的 行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进 行分析以及重写;
2. 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或 者修改索引，使得语句可以尽可能的命中索引;
3. 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大， 如果是的话可以进行横向或者纵向的分表。
```



## 表结构优化

### 1、说一说你能想到的表结构优化，至少五种

```
 永远为每张表设置一个 ID;
 选择正确的存储引擎 ;
 使用可存下数据的最小的数据类型，整型 < date,time <char,varchar < blob;
 使用简单的数据类型，整型比字符处理开销更小，因为字符串的比较更复杂。如，int 类型存储时间类型，bigint 类型转 ip 函数;
 使用合理的字段属性长度，固定长度的表会更快。使用 enum、char而不是 varchar;
 尽可能使用 not null 定义字段(给空字段设置默认值);
 尽量少用 text;
 给频繁使用和查询的字段建立合适的索引。
```

### 2、大表数据查询，怎么优化

```
1. 优化shema、sql语句+索引;

2. 第二加缓存，memcached, redis;

3. 主从复制，读写分离;

4. 垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统;

5. 水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表;
```

### 3、超大分页怎么处理?

```
超大的分页一般从两个方向上来解决.

数据库层面,这也是我们主要集中关注的(虽然收效没那么大),
类似于select * from table where age > 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load 1000000数据然 后基本上全部丢弃,只取10条当然比较慢. 
当时我们可以修改为select * from table where id in (select id from table where age > 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id > 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据. 

从需求的角度减少这种请求...主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允 许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.

解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可. 在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.
【推荐】利用延迟关联或者子查询优化超多分页场景。
说明:MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当 offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改 写。
正例:先快速定位需要获取的id段，然后再关联:
SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id
```

##  数据库优化

### 1、为什么要优化

```
系统的吞吐量瓶颈往往出现在数据库的访问速度上
随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢
数据是存放在磁盘上的，读写速度无法和内存相比

优化原则:减少系统瓶颈，减少资源占用，增加系统的反应速度。
```

### 2、数据库结构优化

```
一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。
需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。
将字段很多的表分解成多个表
对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。
因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。
增加中间表
对于需要经常联合查询的表，可以建立中间表以提高查询效率。
通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。
增加冗余字段
设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。
但是，合理的加入冗余字段可以提高查询速度。
表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。
注意:
冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题
```

### 3、主从复制

```
主从复制:将主数据库中的DDL和DML操作通过二进制日志(BINLOG)传输到从数据库上，然后将这 些日志重新执行(重做);从而使得从数据库的数据与主数据库保持一致。

主从复制的作用
  1. 主数据库出现问题，可以切换到从数据库。 
  2. 可以进行数据库层面的读写分离。
  3. 可以在从数据库上进行日常备份。

MySQL主从复制解决的问题
  数据分布:随意开始或停止复制，并在不同地理位置分布数据备份 
  负载均衡:降低单个服务器的压力 
  高可用和故障切换:帮助应用程序避免单点失败 
  升级测试:可以用更高版本的MySQL作为从库

MySQL主从复制工作原理
  在主库上把数据更高记录到二进制日志
  从库将主库的日志复制到自己的中继日志
  从库读取中继日志的事件，将其重放到从库数据中

基本原理流程，3个线程以及之间的关联 
主:binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中; 
从:io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中; 
从:sql执行线程——执行relay log中的语句;


复制过程
Binary log:主数据库的二进制日志 
Relay log:从服务器的中继日志
第一步:master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。
第二步:salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程 最终的目的是将这些事件写入到中继日志中。
第三步:SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持 一致。
```

### 4、读写分离

```
读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读。

方案一 使用mysql-proxy代理
优点:直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建 议实际生产中使用
缺点:降低性能， 不支持事务 

方案二
使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。 
如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的 insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题，也就是不支持事务，所以我们还需要重写一下DataSourceTransactionManager，将read-only的事务扔进读库，其余的有读有写的扔进写库。

方案三 使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务. 
缺点:类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。
```

#### 如何实现 MySQL 的读写分离？

其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。

#### MySQL 主从复制原理的是啥？

主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。

这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是**有延时**的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。

而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。

所以 MySQL 实际上在这一块有两个机制，一个是**半同步复制**，用来解决主库数据丢失问题；一个是**并行复制**，用来解决主从同步延时问题。

这个所谓**半同步复制**，也叫 `semi-sync` 复制，指的就是主库写入 binlog 日志之后，就会将**强制**此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到**至少一个从库**的 ack 之后才会认为写操作完成了。

所谓**并行复制**，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后**并行重放不同库的日志**，这是库级别的并行。

#### MySQL 主从同步延时问题（精华）

以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小型的生产事故。

是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000/s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。

我们通过 MySQL 命令：

```sql
show slave status
```

查看 `Seconds_Behind_Master` ，可以看到从库复制主库的数据落后了几 ms。

一般来说，如果主从延迟较为严重，有以下解决方案：

- 分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。
- 打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。
- 重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。
- 如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询**设置直连主库**。**不推荐**这种方法，你要是这么搞，读写分离的意义就丧失了。

# 八、存储过程、视图、触发器

## 视图

### 1、为什么要使用视图?什么是视图?

```
为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用 基本表，并且在具体引用视图时动态生成。
视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不
是视图所引用表中的数据，从而提高了数据库中数据的安全性。
```

### 2、视图有哪些特点? 

```
视图的特点如下：
视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。
视图是由基本表(实表)产生的表(虚表)。 
视图的建立和删除不影响基本表。 
对视图内容的更新(添加，删除和修改)直接影响基本表。 
当视图来自多个基本表时，不允许添加和删除数据。
视图的操作包括创建视图，查看视图，删除视图和修改视图。
```

### 3、视图的使用场景有哪些?

```
视图根本用途:简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。 
下面是视图的常见使用场景:
重用SQL语句; 
简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节; 
使用表的组成部分而不是整个表; 
保护数据。
可以给用户授予表的特定部分的访问权限而不是整个表的访问权限; 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。
```

### 4、视图的优点

```
1. 查询简单化。视图能简化用户的操作
2. 数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护 3. 逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性
```

### 5. 视图的缺点

```
1. 性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所 定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的 时间。
2. 修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的这些视图有如下特征:
  1.有UNIQUE等集合操作符的视图。 
  2.有GROUP BY子句的视图。
  3.有诸如AVG\SUM\MAX等聚合函数的视图。
  4.使用DISTINCT关键字的视图。
  5.连接表的视图(其中有些例外)
```

### 6. 什么是游标? 

```
游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。
用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。
```

### 7、视图的作⽤，视图可以更改么？

```
视图是虚拟的表，与包含数据的表不⼀样，视图只包含使⽤时动态检索数据的查询；不包含任何列或数据。使⽤视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使⽤与表相同的⽅式利⽤它们。

视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。

创建视图：create view XXX as XXXXXXXXXXXXXX;

对于某些视图⽐如未使⽤联结⼦查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进⾏更新；但是视图主要⽤于简化检索，保护数据，并不⽤于更新，⽽且⼤部分视图都不可以更新。
```



## 存储过程

### 1、什么是存储过程?有哪些优缺点?

```
存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序 中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。
优点
1)存储过程是预编译过的，执行效率高。 
2)存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。 
3)安全性高，执行存储过程需要有一定权限的用户。 
4)存储过程可以重复使用，减少数据库开发人员的工作量。

缺点
1)调试麻烦，但是用 PL/SQL Developer 调试很方便!弥补这个缺点。
2)移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问 题。
3)重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存 储过程、包将需要重新编译(不过也可以设置成运行时刻自动编译)。
4)如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数 据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价 是空前的，维护起来更麻烦。
```

### 2、存储过程与触发器的区别

```
触发器与存储过程⾮常相似，触发器也是SQL语句集，两者唯⼀的区别是触发器不能⽤EXECUTE语句调⽤，⽽是在⽤户执⾏Transact-SQL语句时⾃动触发（激活）执⾏。触发器是在⼀个修改了指定表中的数据时执⾏的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引⽤完整性和⼀致性。由于⽤户不能绕过触发器，所以可以⽤它来强制实施复杂的业务规则，以确保数据的完整性。

触发器不同于存储过程，触发器主要是通过事件执⾏触发⽽被执⾏的，⽽存储过程可以通过存储过程名称名字⽽直接调⽤。当对某⼀表进⾏诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会⾃动执⾏触发器所定义的SQL语句，从⽽确保对数据的处理必须符合这些SQL语句所定义的规则。
```



## 触发器

### 1、什么是触发器?触发器的使用场景有哪些?

```
触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。
使用场景
可以通过数据库中的相关表实现级联更改。 
实时监控某张表中的某个字段的更改而需要做出相应的处理。 
例如可以生成某些业务的编号。 
注意不要滥用，否则会造成数据库及应用程序的维护困难。 
大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。
```

### 2、MySQL中都有哪些触发器?

```
在MySQL数据库中有如下六种触发器:
Before Insert 
After Insert 
Before Update 
After Update 
Before Delete 
After Delete
```



# 九、其它

### 1、MySQL 数据库 cpu 飙升到 500%的话，该如何处理

```
当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的。
如果不是，找出占用高的进程，并进行相关处理。
如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。
一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。
也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等
```

### 2、LIKE 和 REGEXP 操作有什么区别

```
LIKE匹配整个列。如果被匹配的文本在列值 中出现，LIKE将不会找到它，相应的行也不被返回（除非使用通配符%或_）。
而REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回。
```

### 3、MySQL 表中允许有多少个 TRIGGERS？

```
在 MySQL 表中允许有六个触发器，如下：
BEFORE INSERT
AFTER INSERT
BEFORE UPDATE
AFTER UPDATE
BEFORE DELETE and
AFTER DELETE
```

### 4、MySQL 中 in 和 exists 区别

```
MySQL 中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。
一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。

1. 如果查询的两个表大小相当，那么用in和exists差别不大。

2. 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。

3. not in 和not exists:如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引;

   而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。
```

### 5、UNION与UNION ALL的区别? 

```
如果使用UNION ALL，不会合并重复的记录行

效率 UNION 高于 UNION ALL
```

### 6、MySQL **的数据如何恢复到任意时间点？**

参考答案：

恢复到任意时间点以定时的做全量备份，以及备份增量的 binlog ⽇志为前提。恢复到任意时间点⾸先将全量备份恢复之后，再此基础上回放增加的 binlog直⾄指定的时间点。
