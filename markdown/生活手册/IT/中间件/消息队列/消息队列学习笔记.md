# ⼀、 什么是消息队列

  我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供⾃己使用。

消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。⽬前使用较多的消息队列有ActiveMQ，RabbitMQ，Kafka，RocketMQ。

消息：就是要传输的数据，可以是最简单的文本字符串，也可以是自定义的复杂格式（只要能按预定格式解析出来即可）。

队列 Queue 是一种先进先出的数据结构，它是存放消息的容器，消息从队尾入队，从队头出队，入队即发消息的过程，出队即收消息的过程，所以消费消息时也是按照顺序来消费的。比如⽣生产者发送消息1,2,3...对于消费者就会按照1,2,3...的顺序来消费。

但是偶尔也会出现消息被消费的顺序不一致的情况，比如某个消息消费失败又或者一个 queue 多个consumer 也会导致消息被消费的顺序不对，我们一定要保证消息被消费的顺序正确。

 除了上⾯说的消息消费顺序的问题，使用消息队列，我们还要考虑如何保证消息不被重复消费?如何保证消息的可靠性传输(如何处理消息丢失的问题)?......等等问题。所以说使用消息队列也不是⼗全⼗美的，使用它也会让系统可用性降低、复杂度提⾼，另外需要我们保障一致性等问题。

## 与RPC 有什么联系和区别

<div align="center"> <img src="https://www.hualigs.cn/image/6050588556207.jpg"/> </div><br>

通过对比，能很明显地看出两点差异：

> 1、引入 MQ 后，由之前的一次 RPC 变成了现在的两次 RPC，而且生产者只跟队列耦合，它根本无需知道消费者的存在。
> 2、多了一个中间节点「队列」进行消息转储，相当于将同步变成了异步。
> 再返过来思考 MQ 的所有应用场景，就不难理解 MQ 为什么适用了？因为这些应用场景无外乎都利用了上面两个特性。
> 举一个实际例子，比如说电商业务中最常见的「订单支付」场景：在订单支付成功后，需要更新订单状态、更新用户积分、通知商家有新订单、更新推荐系统中的用户画像等等。

<div align="center"> <img src="https://www.hualigs.cn/image/6050589c3d563.jpg"/> </div><br>

引入 MQ 后，订单支付现在只需要关注它最重要的流程：更新订单状态即可。其他不重要的事情全部交给 MQ 来通知。这便是 MQ 解决的最核心的问题：系统解耦。
改造前订单系统依赖 3 个外部系统，改造后仅仅依赖 MQ，而且后续业务再扩展（比如：营销系统打算针对支付用户奖励优惠券），也不涉及订单系统的修改，从而保证了核心流程的稳定性，降低了维护成本。
这个改造还带来了另外一个好处：因为 MQ 的引入，更新用户积分、通知商家、更新用户画像这些步骤全部变成了异步执行，能减少订单支付的整体耗时，提升订单系统的吞吐量。这便是 MQ 的另一个典型应用场景：异步通信。
除此以外，由于队列能转储消息，对于超出系统承载能力的场景，可以用 MQ 作为 “漏斗” 进行限流保护，即所谓的流量削峰。
我们还可以利用队列本身的顺序性，来满足消息必须按顺序投递的场景；利用队列 + 定时任务来实现消息的延时消费 ……

# 二、为什么要用消息队列

使用消息队列的好处尽量结合自己的实际项目来谈，主要有两点好处：

## 1、通过异步处理提高系统性能（削峰、减少响应所需时间）

在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步导入数据库。由于消息队列服务器处理速度快于数据库，同时消息队列也比数据库有更好的伸缩性，因此响应速度得到大幅改善。

通过上述分析，消息队列具有很好的削峰作用的功能——通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。比如在电子商务一些秒杀、促销活动中，合理利用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。

因为用户请求数据写入消息队列后就立即返回给客户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或者短信通知用户订单提交成功，以免发生交易纠纷。这就类似于我们平时购买火车票或者电影票。再比如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。但是只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。

## 2、降低系统耦合性

我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其它模块影响较小，这样系统的可扩展性无疑更好一些。

最常见的事件驱动架构类似生产者消费者模式，在大型网站中通常利用消息队列实现事件驱动结构。

消息队列利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或者多个消息接收者（消费者）订阅消息。消息发送者（生产者）和消息接收者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接收者从分布式消息队列获取该消息后进⾏后续处理，并不需要知道该消息从何⽽来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从⽽实现⽹站业务的可扩展性设计。

消息接收者对消息进⾏过滤、处理、包装后，构造成⼀个新的消息类型，将消息继续发送出去，等待其他消息接收者订阅该消息。因此基于事件(消息对象)驱动的业务架构可以是一系列流程。

另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。

备注: 不要认为消息队列只能利用发布-订阅模式⼯作，只不过在解耦这个特定业务环境下是使⽤发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式(一个消息只有⼀个消费者)，我们比较常用的是发布-订阅模式。 另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。

# 三、使⽤消息队列带来的⼀些问题

## 系统可⽤性降低

系统可⽤性在某种程度上降低，因为在加入MQ之前，不⽤考虑消息丢失或者说MQ挂掉等的情况，但是，引⼊MQ之后就需要去考虑这些问题!

### 解决方案

#### 发送端的可靠性

发送端完成操作后一定能将消息成功发送到消息队列中。

实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。

#### 接收端的可靠性

接收端能够从消息队列成功消费一次消息。

两种实现方法：

- 保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。
- 保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。

## 系统复杂性提⾼

加⼊MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等问题!

## 一致性问题

消息队列可以实现异步，消息队列带来的异步确实可以提⾼系统响应速度。但是万一消息的真正消费者并没有正确消费消息怎么办?这样就会导致数据不一致的情况!

# 四、JMS VS AMQP

## 1、JMS

### 简介

JMS(JAVA Message Service,Java消息服务)是Java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。**JMS**(**JAVA Message Service**，**Java**消息服务)**API**是⼀个消息服务的标准或者说是规范，允许应⽤程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。

**ActiveMQ** 就是基于 **JMS** 规范实现的。

### JMS两种消息模型

#### 点对点（P2P）

使用**队列（Queue）**作为消息通信载体，满足生产者与消费者模式，消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。未被消费的消息在队列中保留直到被消费或者超时。比如：生产者发送100条消息，两个消费者来消费，一般情况下两个消费者会按照消息发送的顺序各自消费一半的消息。（也就是你一个我一个交叉消费消息）

它允许多个生产者往同一个队列发送消息。但是，如果有多个消费者，实际上是竞争的关系，也就是一条消息只能被其中一个消费者接收到，读完即被删除。如果需要将一份消息数据分发给多个消费者，并且每个消费者都要求收到全量的消息。很显然，队列模型无法满足这个需求。

一个可行的方案是：为每个消费者创建一个单独的队列，让生产者发送多份。这种做法比较笨，而且同一份数据会被复制多份，也很浪费空间。
为了解决这个问题，就演化出了另外一种消息模型：发布-订阅模型。

<div align="center"> <img src="https://www.hualigs.cn/image/605058509129c.jpg"/> </div><br>

#### 发布/订阅（Pub/Sub）

使用**主题（Topic）**作为消息通信载体，类似于广播模式；消息生产者向频道发送一个消息之后，该消息通过主题传递给所有的订阅者并被消费，在一条消息广播之后才订阅的消费者是收不到该条消息的。

仔细对比下它和 “队列模式” 的异同：生产者就是发布者，队列就是主题，消费者就是订阅者，无本质区别。唯一的不同点在于：一份消息数据是否可以被多次消费。

<div align="center"> <img src="https://www.hualigs.cn/image/605058763d634.jpg"/> </div><br>

发布与订阅模式和观察者模式有以下不同：

- 观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。
- 观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011747967.png"/> </div><br>

### JMS五种不同的消息正文格式

JMS定义了五种不同的消息正⽂格式，以及调用的消息类型，允许发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。

| 格式          | 解释                 |
| ------------- | -------------------- |
| StreamMessage | Java原始值的数据流   |
| MapMessage    | ⼀套键值对           |
| TextMessage   | ⼀个字符串对象       |
| ObjectMessage | ⼀个序列化的Java对象 |
| BytesMessage  | ⼀个字节的数据流     |

### 小结

上面两种模型说白了就是：单播和广播的区别。而且，当发布-订阅模型中只有 1 个订阅者时，它和队列模型就一样了，因此在功能上是完全兼容队列模型的。
这也解释了为什么现代主流的 RocketMQ、Kafka 都是直接基于发布-订阅模型实现的？此外，RabbitMQ 中之所以有一个 Exchange 模块？其实也是为了解决消息的投递问题，可以变相实现发布-订阅模型。
包括大家接触到的 “消费组”、“集群消费”、“广播消费” 这些概念，都和上面这两种模型相关，以及在应用层面大家最常见的情形：组间广播、组内单播，也属于此范畴。

## 2、AMQP

AMQP 全称是：Advanced Message Queuing Protocol。`AMQP` 模型目前最新的版本是 `1.0` 版本，但是目前官方推荐使用者的最佳版本仍是基于 `0.9.1` 版本的 `AMQP` 模型。

`AMQP 0-9-1`（高级消息队列协议）是一种消息传递协议，它允许符合标准的客户端应用程序与符合标准的消息传递中间件代理进行通信。消息传递代理（Broker）从发布者（Publisher，即发布消息的应用程序，也称为生产者：Producter）接收消息，并将其路由到使用者（消费者：Consumer，即处理消息的应用程序）。

`AMQP 0-9-1` 模型的核心思想为：消息被发布到交换处，通常被比作邮局或邮箱。然后，交换机使用称为绑定的规则将消息副本分发到队列。然后，代理将消息传递给订阅了队列的使用者，或者使用者根据需要从队列中获取/提取消息。

## 3、JMS VS AMQP

| 对比           | JMS                                                          | AMQP                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义/本质/性质 | Java API                                                     | 协议                                                         |
| 是否跨语言     | 否                                                           | 是                                                           |
| 是否跨平台     | 否                                                           | 是                                                           |
| 消息模型       | ①P2P，点对点模型<br />②Pub/Sub，发布/订阅模型                | ①direct exchange；<br />②fanout exchange； <br />③topic change；<br />④headers exchange；<br />⑤system exchange。<br />本质上后四种和JMS的Pub/Sub模型没有太⼤差别，仅是在路由机制上做了更详细的划分 |
| 消息正⽂格式   | ①StreamMessage；<br />②MapMessage； <br />③TextMessage；<br />④ObjectMessage；<br />⑤BytesMessage | byte[]（⼆进制）                                             |

### 总结

AMQP 为消息定义了线路层（wire-level protocol）的协议，⽽JMS所定义的是API规范。在 Java体系中，多个client均可以通过JMS进⾏交互，不需要应⽤修改代码，但是其对跨平台的⽀持较差。⽽AMQP天然具有跨平台、跨语⾔特性。

JMS ⽀持TextMessage、MapMessage 等复杂的消息类型；⽽ AMQP 仅⽀持 byte[] 消息类型（复杂的类型可序列化后发送）。

由于Exchange 提供的路由算法，AMQP可以提供多样化的路由⽅式来传递消息到消息队列，⽽JMS 仅⽀持 队列 和 主题/订阅 ⽅式两种。

 

# 五、常⻅的消息队列对⽐

| 对比要素 | 概要                                                         |
| -------- | ------------------------------------------------------------ |
| 吞吐量   | 万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要⽐⼗万级甚⾄是百万级的 RocketMQ 和 Kafka 低⼀个数量级。 |
| 可用性   | 都可以实现⾼可⽤。ActiveMQ 和 RabbitMQ 都是基于主从架构实现⾼可⽤性。RocketMQ基于分布式架构。 Kafka 也是分布式的，⼀个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可⽤ |
| 时效性   | RabbitMQ 基于erlang开发，所以并发能⼒很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。 |
| 功能支持 | 除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要⽀持简单的MQ功能，在⼤数据领域的实时计算以及⽇志采集被⼤规模使⽤，是事实上的标准 |
| 消息丢失 | ActiveMQ 和 RabbitMQ 丢失的可能性⾮常低， RocketMQ 和 Kafka 理论上不会丢失。 |

## 总结

ActiveMQ 的社区算是⽐较成熟，但是较⽬前来说，ActiveMQ 的性能⽐较差，⽽且版本迭代很慢，不推荐使⽤。

RabbitMQ 在吞吐量⽅⾯虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能⼒很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实⼒做erlang源码级别的研究和定制。如果业务场景对并发量要求不是太⾼（⼗万级、百万级），那这四种消息队列中，RabbitMQ ⼀定是你的⾸选。如果是⼤数据领域的实时计算、⽇志采集等场景，⽤ Kafka 是业内标准的，绝对没问题，社区活跃度很⾼，绝对不会⻩，何况⼏乎是全世界这个领域的事实性规范。

RocketMQ 阿⾥出品，Java 系开源项⽬，源代码我们可以直接阅读，然后可以定制⾃⼰公司的MQ，并且 RocketMQ 有阿⾥巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为⼀般，不过也还可以，⽂档相对来说简单⼀些，然后接⼝这块不是按照标准 JMS 规范⾛的有些系统要迁移需要修改⼤量代码。还有就是阿⾥出台的技术，你得做好这个技术万⼀被抛弃，社区⻩掉的⻛险，那如果你们公司有技术实⼒我觉得⽤RocketMQ 挺好的。

Kafka 的特点其实很明显，就是仅仅提供较少的核⼼功能，但是提供超⾼的吞吐量，ms 级的延迟，极⾼的可⽤性以及可靠性，⽽且分布式可以任意扩展。同时 Kafka 最好是⽀撑较少的 topic 数量即可，保证其超⾼吞吐量。Kafka 唯⼀的⼀点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在⼤数据领域中以及⽇志采集中，这点轻微影响可以忽略这个特性天然适合⼤数据实时计算以及⽇志收集。

# 六、如何自己设计一个MQ

## MQ的雏形

一发一存一消费，这是 MQ 最核心的功能需求。另外，从技术维度来看 MQ 的通信模型，可以理解成：两次 RPC + 消息转储。

1、直接利用成熟的 RPC 框架（Dubbo 或者 Thrift），实现两个接口：发消息和读消息。
2、消息放在本地内存中即可，数据结构可以用 JDK 自带的 ArrayBlockingQueue 。

## 可用于生产环境的消息中间件

- 1、先把握这个问题的关键点
  假如我们还是只考虑最基础的功能：发消息、存消息、消费消息（支持发布-订阅模式）。
  那在生产环境中，这些基础功能将面临哪些挑战呢？我们能很快想到下面这些：

> 1、高并发场景下，如何保证收发消息的性能？
> 2、如何保证消息服务的高可用和高可靠？
> 3、如何保证服务是可以水平任意扩展的？
> 4、如何保证消息存储也是水平可扩展的？
> 5、各种元数据（比如集群中的各个节点、主题、消费关系等）如何管理，需不需要考虑数据的一致性？
> 可见，高并发场景下的三高问题在你设计一个 MQ 时都会遇到，「如何满足高性能、高可靠等非功能性需求」才是这个问题的关键所在。

- 2、整体设计思路

先来看下整体架构，会涉及三类角色：

<div align="center"> <img src="https://www.hualigs.cn/image/605058d9e1088.jpg"/> </div><br>

另外，将「一发一存一消费」这个核心流程进一步细化后，比较完整的数据流如下：

<div align="center"> <img src="https://www.hualigs.cn/image/605058f115e05.jpg"/> </div><br>

基于上面两个图，我们可以很快明确出 3 类角色的作用，分别如下：

> 1、Broker（服务端）：MQ 中最核心的部分，是 MQ 的服务端，核心逻辑几乎全在这里，它为生产者和消费者提供 RPC 接口，负责消息的存储、备份和删除，以及消费关系的维护等。
> 2、Producer（生产者）：MQ 的客户端之一，调用 Broker 提供的 RPC 接口发送消息。
> 3、Consumer（消费者）：MQ 的另外一个客户端，调用 Broker 提供的 RPC 接口接收消息，同时完成消费确认。

## 详细设计

### RPC通信

解决的是 Broker 与 Producer 以及 Consumer 之间的通信问题。如果不重复造轮子，直接利用成熟的 RPC 框架 Dubbo 或者 Thrift 实现即可，这样不需要考虑服务注册与发现、负载均衡、通信协议、序列化方式等一系列问题了。

当然，你也可以基于 Netty 来做底层通信，用 Zookeeper、Euraka 等来做注册中心，然后自定义一套新的通信协议（类似 Kafka），也可以基于 AMQP 这种标准化的 MQ 协议来做实现（类似 RabbitMQ）。对比直接用 RPC 框架，这种方案的定制化能力和优化空间更大。

### 高可用设计

高可用主要涉及两方面：Broker 服务的高可用、存储方案的高可用。可以拆开讨论。
Broker 服务的高可用，只需要保证 Broker 可水平扩展进行集群部署即可，进一步通过服务自动注册与发现、负载均衡、超时重试机制、发送和消费消息时的 ack 机制来保证。
存储方案的高可用有两个思路：1）参考 Kafka 的分区 + 多副本模式，但是需要考虑分布式场景下数据复制和一致性方案（类似 Zab、Raft等协议），并实现自动故障转移；2）还可以用主流的 DB、分布式文件系统、带持久化能力的 KV 系统，它们都有自己的高可用方案。

### 存储设计

消息的存储方案是 MQ 的核心部分，可靠性保证已经在高可用设计中谈过了，可靠性要求不高的话直接用内存或者分布式缓存也可以。这里重点说一下存储的高性能如何保证？这个问题的决定因素在于存储结构的设计。

目前主流的方案是：追加写日志文件（数据部分） + 索引文件的方式（很多主流的开源 MQ 都是这种方式），索引设计上可以考虑稠密索引或者稀疏索引，查找消息可以利用跳转表、二分查找等，还可以通过操作系统的页缓存、零拷贝等技术来提升磁盘文件的读写性能。

如果不追求很高的性能，也可以考虑现成的分布式文件系统、KV 存储或者数据库方案。

### 消息关系管理

为了支持发布-订阅的广播模式，Broker 需要知道每个主题都有哪些 Consumer 订阅了，基于这个关系进行消息投递。
由于 Broker 是集群部署的，所以消费关系通常维护在公共存储上，可以基于 Zookeeper、Apollo 等配置中心来管理以及进行变更通知。

### 高性能设计

存储的高性能前面已经谈过了，当然还可以从其他方面进一步优化性能。
比如 Reactor 网络 IO 模型、业务线程池的设计、生产端的批量发送、Broker 端的异步刷盘、消费端的批量拉取等等。

### 小结

再总结下，要回答好：如何设计一个 MQ？

1、需要从功能性需求（收发消息）和非功能性需求（高性能、高可用、高扩展等）两方面入手。
2、功能性需求不是重点，能覆盖 MQ 最基础的功能即可，至于延时消息、事务消息、重试队列等高级特性只是锦上添花的东西。
3、最核心的是：能结合功能性需求，理清楚整体的数据流，然后顺着这个思路去考虑非功能性的诉求如何满足，这才是技术难点所在。

